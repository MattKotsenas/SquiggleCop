{
  "$schema": "http://json.schemastore.org/sarif-2.1.0",
  "version": "2.1.0",
  "runs": [
    {
      "results": [
        {
          "ruleId": "CS1998",
          "ruleIndex": 1362,
          "level": "warning",
          "message": {
            "text": "This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 62,
                  "endLine": 10,
                  "endColumn": 72
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CS1591",
          "ruleIndex": 1363,
          "level": "warning",
          "message": {
            "text": "Missing XML comment for publicly visible type or member 'SarifParser'"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 14,
                  "endLine": 6,
                  "endColumn": 25
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 4
          }
        },
        {
          "ruleId": "CS1591",
          "ruleIndex": 1363,
          "level": "warning",
          "message": {
            "text": "Missing XML comment for publicly visible type or member 'SarifParser.ParseAsync(Stream)'"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 62,
                  "endLine": 10,
                  "endColumn": 72
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 4
          }
        },
        {
          "ruleId": "MA0026",
          "ruleIndex": 432,
          "level": "note",
          "message": {
            "text": "TODO Add an entry for if it's suppressed in source"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/DiagnosticConfig.cs"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 33,
                  "endLine": 4,
                  "endColumn": 84
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "S1135",
          "ruleIndex": 886,
          "level": "note",
          "message": {
            "text": "Complete the task associated to this 'TODO' comment."
          },
          "suppressions": [
            {
              "kind": "inSource",
              "properties": {
                "suppressionType": "Pragma Directive"
              }
            }
          ],
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/DiagnosticConfig.cs"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 33,
                  "endLine": 4,
                  "endColumn": 37
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "MA0026",
          "ruleIndex": 432,
          "level": "note",
          "message": {
            "text": "TODO Note that the stream is borrowed here and won't be closed"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 8,
                  "endLine": 8,
                  "endColumn": 71
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "MA0026",
          "ruleIndex": 432,
          "level": "note",
          "message": {
            "text": "TODO Should we use deferred loading?"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 16,
                  "endLine": 14,
                  "endColumn": 53
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "MA0026",
          "ruleIndex": 432,
          "level": "note",
          "message": {
            "text": "TODO Assert minimum version of compiler"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 16,
                  "endLine": 17,
                  "endColumn": 56
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "MA0026",
          "ruleIndex": 432,
          "level": "note",
          "message": {
            "text": "TODO Find stream-compatible way to test for SARIF v1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 16,
                  "endLine": 23,
                  "endColumn": 69
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "S125",
          "ruleIndex": 907,
          "level": "warning",
          "message": {
            "text": "Remove this commented out code."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 13,
                  "endLine": 25,
                  "endColumn": 17
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "S1135",
          "ruleIndex": 886,
          "level": "note",
          "message": {
            "text": "Complete the task associated to this 'TODO' comment."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 8,
                  "endLine": 8,
                  "endColumn": 12
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "S1135",
          "ruleIndex": 886,
          "level": "note",
          "message": {
            "text": "Complete the task associated to this 'TODO' comment."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 16,
                  "endLine": 14,
                  "endColumn": 20
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "S1135",
          "ruleIndex": 886,
          "level": "note",
          "message": {
            "text": "Complete the task associated to this 'TODO' comment."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 16,
                  "endLine": 17,
                  "endColumn": 20
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "S1135",
          "ruleIndex": 886,
          "level": "note",
          "message": {
            "text": "Complete the task associated to this 'TODO' comment."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 16,
                  "endLine": 23,
                  "endColumn": 20
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "S1144",
          "ruleIndex": 887,
          "level": "warning",
          "message": {
            "text": "Remove the unused private method 'IsVersion1FileAsync'."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 30,
                  "endLine": 61,
                  "endColumn": 49
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "RCS1213",
          "ruleIndex": 752,
          "level": "note",
          "message": {
            "text": "Remove unused method declaration"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 30,
                  "endLine": 61,
                  "endColumn": 49
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "RCS1214",
          "ruleIndex": 753,
          "level": "note",
          "message": {
            "text": "Unnecessary interpolated string"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 44,
                  "endLine": 29,
                  "endColumn": 45
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "CA1822",
          "ruleIndex": 101,
          "level": "note",
          "message": {
            "text": "Member 'IsVersion1FileAsync' does not access instance data and can be marked as static"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 30,
                  "endLine": 61,
                  "endColumn": 49
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "IDE0051",
          "ruleIndex": 341,
          "level": "note",
          "message": {
            "text": "Private member 'SarifParser.IsVersion1FileAsync' is unused"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 30,
                  "endLine": 61,
                  "endColumn": 49
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "MA0038",
          "ruleIndex": 443,
          "level": "note",
          "message": {
            "text": "Make method static (deprecated, use CA1822 instead)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 30,
                  "endLine": 61,
                  "endColumn": 49
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        },
        {
          "ruleId": "MA0038",
          "ruleIndex": 443,
          "level": "note",
          "message": {
            "text": "Make method static (deprecated, use CA1822 instead)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:///C:/Projects/SquiggleCop/src/Common/SarifParser.cs"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 43,
                  "endLine": 33,
                  "endColumn": 51
                }
              }
            }
          ],
          "properties": {
            "warningLevel": 1
          }
        }
      ],
      "properties": {
        "analyzerExecutionTime": "15.126"
      },
      "tool": {
        "driver": {
          "name": "Microsoft (R) Visual C# Compiler",
          "version": "4.10.0-3.24314.14 (259e82e9)",
          "dottedQuadFileVersion": "4.10.0.0",
          "semanticVersion": "4.10.0",
          "language": "en-US",
          "rules": [
            {
              "id": "CA1000",
              "shortDescription": {
                "text": "Do not declare static members on generic types"
              },
              "fullDescription": {
                "text": "When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1000",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1001",
              "shortDescription": {
                "text": "Types that own disposable fields should be disposable"
              },
              "fullDescription": {
                "text": "A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1001",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1002",
              "shortDescription": {
                "text": "Do not expose generic lists"
              },
              "fullDescription": {
                "text": "System.Collections.Generic.List<T> is a generic collection that's designed for performance and not inheritance. List<T> does not contain virtual members that make it easier to change the behavior of an inherited class."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1002",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1003",
              "shortDescription": {
                "text": "Use generic event handler instances"
              },
              "fullDescription": {
                "text": "A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1003",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1005",
              "shortDescription": {
                "text": "Avoid excessive parameters on generic types"
              },
              "fullDescription": {
                "text": "The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1005",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "CA1008",
              "shortDescription": {
                "text": "Enums should have zero value"
              },
              "fullDescription": {
                "text": "The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be \"\"None\"\" to indicate that no values have been set in the enumeration."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1008",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "RuleRename"
                ]
              }
            },
            {
              "id": "CA1010",
              "shortDescription": {
                "text": "Generic interface should also be implemented"
              },
              "fullDescription": {
                "text": "To broaden the usability of a type, implement one of the generic interfaces. This is especially true for collections as they can then be used to populate generic collection types."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1010",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1012",
              "shortDescription": {
                "text": "Abstract types should not have public constructors"
              },
              "fullDescription": {
                "text": "Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1012",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1014",
              "shortDescription": {
                "text": "Mark assemblies with CLSCompliant"
              },
              "fullDescription": {
                "text": "The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1014",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1016",
              "shortDescription": {
                "text": "Mark assemblies with assembly version"
              },
              "fullDescription": {
                "text": "The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1016",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1017",
              "shortDescription": {
                "text": "Mark assemblies with ComVisible"
              },
              "fullDescription": {
                "text": "ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1017",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1018",
              "shortDescription": {
                "text": "Mark attributes with AttributeUsageAttribute"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1018",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1019",
              "shortDescription": {
                "text": "Define accessors for attribute arguments"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1019",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1021",
              "shortDescription": {
                "text": "Avoid out parameters"
              },
              "fullDescription": {
                "text": "Passing types by reference (using 'out' or 'ref') requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between 'out' and 'ref' parameters is not widely understood."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1021",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "CA1024",
              "shortDescription": {
                "text": "Use properties where appropriate"
              },
              "fullDescription": {
                "text": "A public or protected method has a name that starts with \"\"Get\"\", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1024",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1027",
              "shortDescription": {
                "text": "Mark enums with FlagsAttribute"
              },
              "fullDescription": {
                "text": "An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1027",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1028",
              "shortDescription": {
                "text": "Enum Storage should be Int32"
              },
              "fullDescription": {
                "text": "An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1028",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1030",
              "shortDescription": {
                "text": "Use events where appropriate"
              },
              "fullDescription": {
                "text": "This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1030",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1031",
              "shortDescription": {
                "text": "Do not catch general exception types"
              },
              "fullDescription": {
                "text": "A general exception such as System.Exception or System.SystemException or a disallowed exception type is caught in a catch statement, or a general catch clause is used. General and disallowed exceptions should not be caught."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1031",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1032",
              "shortDescription": {
                "text": "Implement standard exception constructors"
              },
              "fullDescription": {
                "text": "Failure to provide the full set of constructors can make it difficult to correctly handle exceptions."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1032",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1033",
              "shortDescription": {
                "text": "Interface methods should be callable by child types"
              },
              "fullDescription": {
                "text": "An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1033",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1034",
              "shortDescription": {
                "text": "Nested types should not be visible"
              },
              "fullDescription": {
                "text": "A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1034",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1036",
              "shortDescription": {
                "text": "Override methods on comparable types"
              },
              "fullDescription": {
                "text": "A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1036",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1040",
              "shortDescription": {
                "text": "Avoid empty interfaces"
              },
              "fullDescription": {
                "text": "Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1040",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1041",
              "shortDescription": {
                "text": "Provide ObsoleteAttribute message"
              },
              "fullDescription": {
                "text": "A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1041",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.052",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1043",
              "shortDescription": {
                "text": "Use Integral Or String Argument For Indexers"
              },
              "fullDescription": {
                "text": "Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1043",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1044",
              "shortDescription": {
                "text": "Properties should not be write only"
              },
              "fullDescription": {
                "text": "Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1044",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1045",
              "shortDescription": {
                "text": "Do not pass types by reference"
              },
              "fullDescription": {
                "text": "Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Also, the difference between out and ref parameters is not widely understood."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1045",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "CA1046",
              "shortDescription": {
                "text": "Do not overload equality operator on reference types"
              },
              "fullDescription": {
                "text": "For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object. If the operator is providing meaningful value equality, the type should implement the generic 'System.IEquatable' interface."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1046",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1050",
              "shortDescription": {
                "text": "Declare types in namespaces"
              },
              "fullDescription": {
                "text": "Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1050",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1051",
              "shortDescription": {
                "text": "Do not declare visible instance fields"
              },
              "fullDescription": {
                "text": "The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1051",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1052",
              "shortDescription": {
                "text": "Static holder types should be Static or NotInheritable"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1052",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1054",
              "shortDescription": {
                "text": "URI-like parameters should not be strings"
              },
              "fullDescription": {
                "text": "This rule assumes that the parameter represents a Uniform Resource Identifier (URI). A string representation or a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. 'System.Uri' class provides these services in a safe and secure manner."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1054",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1055",
              "shortDescription": {
                "text": "URI-like return values should not be strings"
              },
              "fullDescription": {
                "text": "This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1055",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1056",
              "shortDescription": {
                "text": "URI-like properties should not be strings"
              },
              "fullDescription": {
                "text": "This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1056",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1058",
              "shortDescription": {
                "text": "Types should not extend certain base types"
              },
              "fullDescription": {
                "text": "An externally visible type extends certain base types. Use one of the alternatives."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1058",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1060",
              "shortDescription": {
                "text": "Move pinvokes to native methods class"
              },
              "fullDescription": {
                "text": "Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1060",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "CA1061",
              "shortDescription": {
                "text": "Do not hide base class methods"
              },
              "fullDescription": {
                "text": "A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1061",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1062",
              "shortDescription": {
                "text": "Validate arguments of public methods"
              },
              "fullDescription": {
                "text": "An externally visible method dereferences one of its reference arguments without verifying whether that argument is 'null' ('Nothing' in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against 'null'. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'. If the method is designed to be called only by known assemblies, you should make the method internal."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1062",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1063",
              "shortDescription": {
                "text": "Implement IDisposable Correctly"
              },
              "fullDescription": {
                "text": "All IDisposable types should implement the Dispose pattern correctly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1063",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1064",
              "shortDescription": {
                "text": "Exceptions should be public"
              },
              "fullDescription": {
                "text": "An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1064",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1065",
              "shortDescription": {
                "text": "Do not raise exceptions in unexpected locations"
              },
              "fullDescription": {
                "text": "A method that is not expected to throw exceptions throws an exception."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1065",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1066",
              "shortDescription": {
                "text": "Implement IEquatable when overriding Object.Equals"
              },
              "fullDescription": {
                "text": "When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable<T>, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable<T>.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1066",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1067",
              "shortDescription": {
                "text": "Override Object.Equals(object) when implementing IEquatable<T>"
              },
              "fullDescription": {
                "text": "When a type T implements the interface IEquatable<T>, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the \"principle of least surprise\"."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1067",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1068",
              "shortDescription": {
                "text": "CancellationToken parameters must come last"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1068",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1069",
              "shortDescription": {
                "text": "Enums values should not be duplicated"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1069",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1070",
              "shortDescription": {
                "text": "Do not declare event fields as virtual"
              },
              "fullDescription": {
                "text": "Do not declare virtual events in a base class. Overridden events in a derived class have undefined behavior. The C# compiler does not handle this correctly and it is unpredictable whether a subscriber to the derived event will actually be subscribing to the base class event."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1070",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1200",
              "shortDescription": {
                "text": "Avoid using cref tags with a prefix"
              },
              "fullDescription": {
                "text": "Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1200",
              "properties": {
                "category": "Documentation",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1303",
              "shortDescription": {
                "text": "Do not pass literals as localized parameters"
              },
              "fullDescription": {
                "text": "A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1303",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1304",
              "shortDescription": {
                "text": "Specify CultureInfo"
              },
              "fullDescription": {
                "text": "A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1304",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1305",
              "shortDescription": {
                "text": "Specify IFormatProvider"
              },
              "fullDescription": {
                "text": "A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1305",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1307",
              "shortDescription": {
                "text": "Specify StringComparison for clarity"
              },
              "fullDescription": {
                "text": "A string comparison operation uses a method overload that does not set a StringComparison parameter. It is recommended to use the overload with StringComparison parameter for clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1307",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1308",
              "shortDescription": {
                "text": "Normalize strings to uppercase"
              },
              "fullDescription": {
                "text": "Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1308",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1309",
              "shortDescription": {
                "text": "Use ordinal string comparison"
              },
              "fullDescription": {
                "text": "A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1309",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1310",
              "shortDescription": {
                "text": "Specify StringComparison for correctness"
              },
              "fullDescription": {
                "text": "A string comparison operation uses a method overload that does not set a StringComparison parameter, hence its behavior could vary based on the current user's locale settings. It is strongly recommended to use the overload with StringComparison parameter for correctness and clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1310",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1311",
              "shortDescription": {
                "text": "Specify a culture or use an invariant version"
              },
              "fullDescription": {
                "text": "Specify culture to help avoid accidental implicit dependency on current culture. Using an invariant version yields consistent results regardless of the culture of an application."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1311",
              "properties": {
                "category": "Globalization",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1401",
              "shortDescription": {
                "text": "P/Invokes should not be visible"
              },
              "fullDescription": {
                "text": "A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1401",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1416",
              "shortDescription": {
                "text": "Validate platform compatibility"
              },
              "fullDescription": {
                "text": "Using platform dependent API on a component makes the code no longer work across all platforms."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1416",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.072",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1417",
              "shortDescription": {
                "text": "Do not use 'OutAttribute' on string parameters for P/Invokes"
              },
              "fullDescription": {
                "text": "String parameters passed by value with the 'OutAttribute' can destabilize the runtime if the string is an interned string."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1417",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1418",
              "shortDescription": {
                "text": "Use valid platform string"
              },
              "fullDescription": {
                "text": "Platform compatibility analyzer requires a valid platform name and version."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1418",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.017",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1419",
              "shortDescription": {
                "text": "Provide a parameterless constructor that is as visible as the containing type for concrete types derived from 'System.Runtime.InteropServices.SafeHandle'"
              },
              "fullDescription": {
                "text": "Providing a parameterless constructor that is as visible as the containing type for a type derived from 'System.Runtime.InteropServices.SafeHandle' enables better performance and usage with source-generated interop solutions."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1419",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1420",
              "shortDescription": {
                "text": "Property, type, or attribute requires runtime marshalling"
              },
              "fullDescription": {
                "text": "Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1420",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1421",
              "shortDescription": {
                "text": "This method uses runtime marshalling even when the 'DisableRuntimeMarshallingAttribute' is applied"
              },
              "fullDescription": {
                "text": "This method uses runtime marshalling even when runtime marshalling is disabled, which can cause unexpected behavior differences at runtime due to different expectations of a type's native layout."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1421",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1422",
              "shortDescription": {
                "text": "Validate platform compatibility"
              },
              "fullDescription": {
                "text": "Using platform dependent API on a component makes the code no longer work across all platforms."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1422",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.072",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1501",
              "shortDescription": {
                "text": "Avoid excessive inheritance"
              },
              "fullDescription": {
                "text": "Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1501",
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1502",
              "shortDescription": {
                "text": "Avoid excessive complexity"
              },
              "fullDescription": {
                "text": "Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1502",
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1505",
              "shortDescription": {
                "text": "Avoid unmaintainable code"
              },
              "fullDescription": {
                "text": "The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1505",
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1506",
              "shortDescription": {
                "text": "Avoid excessive class coupling"
              },
              "fullDescription": {
                "text": "This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1506",
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1507",
              "shortDescription": {
                "text": "Use nameof to express symbol names"
              },
              "fullDescription": {
                "text": "Using nameof helps keep your code valid when refactoring."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1507",
              "properties": {
                "category": "Maintainability",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1508",
              "shortDescription": {
                "text": "Avoid dead conditional code"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1508",
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1509",
              "shortDescription": {
                "text": "Invalid entry in code metrics rule specification file"
              },
              "fullDescription": {
                "text": "Invalid entry in code metrics rule specification file."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1509",
              "properties": {
                "category": "Maintainability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1510",
              "shortDescription": {
                "text": "Use ArgumentNullException throw helper"
              },
              "fullDescription": {
                "text": "Throw helpers are simpler and more efficient than an if block constructing a new exception instance."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1510",
              "properties": {
                "category": "Maintainability",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1511",
              "shortDescription": {
                "text": "Use ArgumentException throw helper"
              },
              "fullDescription": {
                "text": "Throw helpers are simpler and more efficient than an if block constructing a new exception instance."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1511",
              "properties": {
                "category": "Maintainability",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1512",
              "shortDescription": {
                "text": "Use ArgumentOutOfRangeException throw helper"
              },
              "fullDescription": {
                "text": "Throw helpers are simpler and more efficient than an if block constructing a new exception instance."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1512",
              "properties": {
                "category": "Maintainability",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1513",
              "shortDescription": {
                "text": "Use ObjectDisposedException throw helper"
              },
              "fullDescription": {
                "text": "Throw helpers are simpler and more efficient than an if block constructing a new exception instance."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1513",
              "properties": {
                "category": "Maintainability",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1700",
              "shortDescription": {
                "text": "Do not name enum values 'Reserved'"
              },
              "fullDescription": {
                "text": "This rule assumes that an enumeration member that has a name that contains \"reserved\" is not currently used but is a placeholder to be renamed or removed in a future version. Renaming or removing a member is a breaking change."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1700",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1707",
              "shortDescription": {
                "text": "Identifiers should not contain underscores"
              },
              "fullDescription": {
                "text": "By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1707",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1708",
              "shortDescription": {
                "text": "Identifiers should differ by more than case"
              },
              "fullDescription": {
                "text": "Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1708",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1710",
              "shortDescription": {
                "text": "Identifiers should have correct suffix"
              },
              "fullDescription": {
                "text": "By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1710",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1711",
              "shortDescription": {
                "text": "Identifiers should not have incorrect suffix"
              },
              "fullDescription": {
                "text": "By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1711",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1712",
              "shortDescription": {
                "text": "Do not prefix enum values with type name"
              },
              "fullDescription": {
                "text": "An enumeration's values should not start with the type name of the enumeration."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1712",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1713",
              "shortDescription": {
                "text": "Events should not have 'Before' or 'After' prefix"
              },
              "fullDescription": {
                "text": "Event names should describe the action that raises the event. To name related events that are raised in a specific sequence, use the present or past tense to indicate the relative position in the sequence of actions. For example, when naming a pair of events that is raised when closing a resource, you might name it 'Closing' and 'Closed', instead of 'BeforeClose' and 'AfterClose'."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1713",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1715",
              "shortDescription": {
                "text": "Identifiers should have correct prefix"
              },
              "fullDescription": {
                "text": "The name of an externally visible interface does not start with an uppercase \"\"I\"\". The name of a generic type parameter on an externally visible type or method does not start with an uppercase \"\"T\"\"."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1715",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1716",
              "shortDescription": {
                "text": "Identifiers should not match keywords"
              },
              "fullDescription": {
                "text": "A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1716",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1720",
              "shortDescription": {
                "text": "Identifier contains type name"
              },
              "fullDescription": {
                "text": "Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1720",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1721",
              "shortDescription": {
                "text": "Property names should not match get methods"
              },
              "fullDescription": {
                "text": "The name of a public or protected member starts with \"\"Get\"\" and otherwise matches the name of a public or protected property. \"\"Get\"\" methods and properties should have names that clearly distinguish their function."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1721",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1724",
              "shortDescription": {
                "text": "Type names should not match namespaces"
              },
              "fullDescription": {
                "text": "Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1724",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1725",
              "shortDescription": {
                "text": "Parameter names should match base declaration"
              },
              "fullDescription": {
                "text": "Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1725",
              "properties": {
                "category": "Naming",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1727",
              "shortDescription": {
                "text": "Use PascalCase for named placeholders"
              },
              "fullDescription": {
                "text": "Use PascalCase for named placeholders in the logging message template."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1727",
              "properties": {
                "category": "Naming",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1802",
              "shortDescription": {
                "text": "Use literals where appropriate"
              },
              "fullDescription": {
                "text": "A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at runtime."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1802",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1805",
              "shortDescription": {
                "text": "Do not initialize unnecessarily"
              },
              "fullDescription": {
                "text": "The .NET runtime initializes all fields of reference types to their default values before running the constructor. In most cases, explicitly initializing a field to its default value in a constructor is redundant, adding maintenance costs and potentially degrading performance (such as with increased assembly size), and the explicit initialization can be removed.  In some cases, such as with static readonly fields that permanently retain their default value, consider instead changing them to be constants or properties."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1805",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1806",
              "shortDescription": {
                "text": "Do not ignore method results"
              },
              "fullDescription": {
                "text": "A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1806",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1810",
              "shortDescription": {
                "text": "Initialize reference type static fields inline"
              },
              "fullDescription": {
                "text": "A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1810",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1812",
              "shortDescription": {
                "text": "Avoid uninstantiated internal classes"
              },
              "fullDescription": {
                "text": "An instance of an assembly-level type is not created by code in the assembly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1812",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1813",
              "shortDescription": {
                "text": "Avoid unsealed attributes"
              },
              "fullDescription": {
                "text": "The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1813",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1814",
              "shortDescription": {
                "text": "Prefer jagged arrays over multidimensional"
              },
              "fullDescription": {
                "text": "A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1814",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1815",
              "shortDescription": {
                "text": "Override equals and operator equals on value types"
              },
              "fullDescription": {
                "text": "For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1815",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1816",
              "shortDescription": {
                "text": "Dispose methods should call SuppressFinalize"
              },
              "fullDescription": {
                "text": "A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic)."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1816",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.021",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1819",
              "shortDescription": {
                "text": "Properties should not return arrays"
              },
              "fullDescription": {
                "text": "Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1819",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1820",
              "shortDescription": {
                "text": "Test for empty strings using string length"
              },
              "fullDescription": {
                "text": "Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1820",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1821",
              "shortDescription": {
                "text": "Remove empty Finalizers"
              },
              "fullDescription": {
                "text": "Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1821",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1822",
              "shortDescription": {
                "text": "Mark members as static"
              },
              "fullDescription": {
                "text": "Members that do not access instance data or call instance methods can be marked as static. After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1822",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.075",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1823",
              "shortDescription": {
                "text": "Avoid unused private fields"
              },
              "fullDescription": {
                "text": "Private fields were detected that do not appear to be accessed in the assembly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1823",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1824",
              "shortDescription": {
                "text": "Mark assemblies with NeutralResourcesLanguageAttribute"
              },
              "fullDescription": {
                "text": "The NeutralResourcesLanguage attribute informs the ResourceManager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1824",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1825",
              "shortDescription": {
                "text": "Avoid zero-length array allocations"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1825",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1826",
              "shortDescription": {
                "text": "Do not use Enumerable methods on indexable collections"
              },
              "fullDescription": {
                "text": "This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1826",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.041",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1827",
              "shortDescription": {
                "text": "Do not use Count() or LongCount() when Any() can be used"
              },
              "fullDescription": {
                "text": "For non-empty collections, Count() and LongCount() enumerate the entire sequence, while Any() stops at the first item or the first item that satisfies a condition."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1827",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1828",
              "shortDescription": {
                "text": "Do not use CountAsync() or LongCountAsync() when AnyAsync() can be used"
              },
              "fullDescription": {
                "text": "For non-empty collections, CountAsync() and LongCountAsync() enumerate the entire sequence, while AnyAsync() stops at the first item or the first item that satisfies a condition."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1828",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1829",
              "shortDescription": {
                "text": "Use Length/Count property instead of Count() when available"
              },
              "fullDescription": {
                "text": "Enumerable.Count() potentially enumerates the sequence while a Length/Count property is a direct access."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1829",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1830",
              "shortDescription": {
                "text": "Prefer strongly-typed Append and Insert method overloads on StringBuilder"
              },
              "fullDescription": {
                "text": "StringBuilder.Append and StringBuilder.Insert provide overloads for multiple types beyond System.String.  When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1830",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1831",
              "shortDescription": {
                "text": "Use AsSpan or AsMemory instead of Range-based indexers when appropriate"
              },
              "fullDescription": {
                "text": "The Range-based indexer on string values produces a copy of requested portion of the string. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1831",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1832",
              "shortDescription": {
                "text": "Use AsSpan or AsMemory instead of Range-based indexers when appropriate"
              },
              "fullDescription": {
                "text": "The Range-based indexer on array values produces a copy of requested portion of the array. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1832",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1833",
              "shortDescription": {
                "text": "Use AsSpan or AsMemory instead of Range-based indexers when appropriate"
              },
              "fullDescription": {
                "text": "The Range-based indexer on array values produces a copy of requested portion of the array. This copy is often unwanted when it is implicitly used as a Span or Memory value. Use the AsSpan method to avoid the copy."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1833",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1834",
              "shortDescription": {
                "text": "Consider using 'StringBuilder.Append(char)' when applicable"
              },
              "fullDescription": {
                "text": "'StringBuilder.Append(char)' is more efficient than 'StringBuilder.Append(string)' when the string is a single character. When calling 'Append' with a constant, prefer using a constant char rather than a constant string containing one character."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1834",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1835",
              "shortDescription": {
                "text": "Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'"
              },
              "fullDescription": {
                "text": "'Stream' has a 'ReadAsync' overload that takes a 'Memory<Byte>' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory<Byte>' as the first argument. Prefer calling the memory based overloads, which are more efficient."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1835",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1836",
              "shortDescription": {
                "text": "Prefer IsEmpty over Count"
              },
              "fullDescription": {
                "text": "For determining whether the object contains or not any items, prefer using 'IsEmpty' property rather than retrieving the number of items from the 'Count' property and comparing it to 0 or 1."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1836",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1837",
              "shortDescription": {
                "text": "Use 'Environment.ProcessId'"
              },
              "fullDescription": {
                "text": "'Environment.ProcessId' is simpler and faster than 'Process.GetCurrentProcess().Id'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1837",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1838",
              "shortDescription": {
                "text": "Avoid 'StringBuilder' parameters for P/Invokes"
              },
              "fullDescription": {
                "text": "Marshalling of 'StringBuilder' always creates a native buffer copy, resulting in multiple allocations for one marshalling operation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1838",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1839",
              "shortDescription": {
                "text": "Use 'Environment.ProcessPath'"
              },
              "fullDescription": {
                "text": "'Environment.ProcessPath' is simpler and faster than 'Process.GetCurrentProcess().MainModule.FileName'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1839",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1840",
              "shortDescription": {
                "text": "Use 'Environment.CurrentManagedThreadId'"
              },
              "fullDescription": {
                "text": "'Environment.CurrentManagedThreadId' is simpler and faster than 'Thread.CurrentThread.ManagedThreadId'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1840",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1841",
              "shortDescription": {
                "text": "Prefer Dictionary.Contains methods"
              },
              "fullDescription": {
                "text": "'ContainsKey' is usually O(1), while 'Keys.Contains' may be O(n) in some cases. Additionally, many dictionary implementations lazily initialize the Keys collection to cut back on allocations."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1841",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1842",
              "shortDescription": {
                "text": "Do not use 'WhenAll' with a single task"
              },
              "fullDescription": {
                "text": "Using 'WhenAll' with a single task may result in performance loss, await or return the task instead."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1842",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1843",
              "shortDescription": {
                "text": "Do not use 'WaitAll' with a single task"
              },
              "fullDescription": {
                "text": "Using 'WaitAll' with a single task may result in performance loss, await or return the task instead."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1843",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1844",
              "shortDescription": {
                "text": "Provide memory-based overrides of async methods when subclassing 'Stream'"
              },
              "fullDescription": {
                "text": "To improve performance, override the memory-based async methods when subclassing 'Stream'. Then implement the array-based methods in terms of the memory-based methods."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1844",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1845",
              "shortDescription": {
                "text": "Use span-based 'string.Concat'"
              },
              "fullDescription": {
                "text": "It is more efficient to use 'AsSpan' and 'string.Concat', instead of 'Substring' and a concatenation operator."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1845",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1846",
              "shortDescription": {
                "text": "Prefer 'AsSpan' over 'Substring'"
              },
              "fullDescription": {
                "text": "'AsSpan' is more efficient then 'Substring'. 'Substring' performs an O(n) string copy, while 'AsSpan' does not and has a constant cost."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1846",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1847",
              "shortDescription": {
                "text": "Use char literal for a single character lookup"
              },
              "fullDescription": {
                "text": "'string.Contains(char)' is available as a better performing overload for single char lookup."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1848",
              "shortDescription": {
                "text": "Use the LoggerMessage delegates"
              },
              "fullDescription": {
                "text": "For improved performance, use the LoggerMessage delegates."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1848",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1849",
              "shortDescription": {
                "text": "Call async methods when in an async method"
              },
              "fullDescription": {
                "text": "When inside a Task-returning method, use the async version of methods, if they exist."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1849",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1850",
              "shortDescription": {
                "text": "Prefer static 'HashData' method over 'ComputeHash'"
              },
              "fullDescription": {
                "text": "It is more efficient to use the static 'HashData' method over creating and managing a HashAlgorithm instance to call 'ComputeHash'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1850",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.095",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1851",
              "shortDescription": {
                "text": "Possible multiple enumerations of 'IEnumerable' collection"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1851",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1852",
              "shortDescription": {
                "text": "Seal internal types"
              },
              "fullDescription": {
                "text": "When a type is not accessible outside its assembly and has no subtypes within its containing assembly, it can be safely sealed. Sealing types can improve performance."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1852",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA1853",
              "shortDescription": {
                "text": "Unnecessary call to 'Dictionary.ContainsKey(key)'"
              },
              "fullDescription": {
                "text": "Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'. The former already checks whether the key exists, and will not throw if it does not."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1853",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1854",
              "shortDescription": {
                "text": "Prefer the 'IDictionary.TryGetValue(TKey, out TValue)' method"
              },
              "fullDescription": {
                "text": "Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check. 'ContainsKey' and the indexer both would lookup the key under the hood, so using 'TryGetValue' removes the extra lookup."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1854",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1855",
              "shortDescription": {
                "text": "Prefer 'Clear' over 'Fill'"
              },
              "fullDescription": {
                "text": "It is more efficient to use 'Clear', instead of 'Fill' with default value."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1855",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1856",
              "shortDescription": {
                "text": "Incorrect usage of ConstantExpected attribute"
              },
              "fullDescription": {
                "text": "ConstantExpected attribute is not applied correctly on the parameter."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1856",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1857",
              "shortDescription": {
                "text": "A constant is expected for the parameter"
              },
              "fullDescription": {
                "text": "The parameter expects a constant for optimal performance."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1857",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1858",
              "shortDescription": {
                "text": "Use 'StartsWith' instead of 'IndexOf'"
              },
              "fullDescription": {
                "text": "It is both clearer and faster to use 'StartsWith' instead of comparing the result of 'IndexOf' to zero."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1858",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1859",
              "shortDescription": {
                "text": "Use concrete types when possible for improved performance"
              },
              "fullDescription": {
                "text": "Using concrete types avoids virtual or interface call overhead and enables inlining."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1859",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.060",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1860",
              "shortDescription": {
                "text": "Avoid using 'Enumerable.Any()' extension method"
              },
              "fullDescription": {
                "text": "Prefer using 'IsEmpty', 'Count' or 'Length' properties whichever available, rather than calling 'Enumerable.Any()'. The intent is clearer and it is more performant than using 'Enumerable.Any()' extension method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1860",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1861",
              "shortDescription": {
                "text": "Avoid constant arrays as arguments"
              },
              "fullDescription": {
                "text": "Constant arrays passed as arguments are not reused when called repeatedly, which implies a new array is created each time. Consider extracting them to 'static readonly' fields to improve performance if the passed array is not mutated within the called method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1861",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.017",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1862",
              "shortDescription": {
                "text": "Use the 'StringComparison' method overloads to perform case-insensitive string comparisons"
              },
              "fullDescription": {
                "text": "Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons because they lead to an allocation. Instead, prefer calling the method overloads of 'Contains', 'IndexOf' and 'StartsWith' that take a 'StringComparison' enum value to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1862",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1863",
              "shortDescription": {
                "text": "Use 'CompositeFormat'"
              },
              "fullDescription": {
                "text": "Cache and use a 'CompositeFormat' instance as the argument to this formatting operation, rather than passing in the original format string. This reduces the cost of the formatting operation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1863",
              "properties": {
                "category": "Performance",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1864",
              "shortDescription": {
                "text": "Prefer the 'IDictionary.TryAdd(TKey, TValue)' method"
              },
              "fullDescription": {
                "text": "Prefer a 'TryAdd' call over an 'Add' call guarded by a 'ContainsKey' check. 'TryAdd' behaves the same as 'Add', except that when the specified key already exists, it returns 'false' instead of throwing an exception."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1864",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1865",
              "shortDescription": {
                "text": "Use char overload"
              },
              "fullDescription": {
                "text": "The char overload is a better performing overload than a string with a single char."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1865",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.067",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1866",
              "shortDescription": {
                "text": "Use char overload"
              },
              "fullDescription": {
                "text": "The char overload is a better performing overload than a string with a single char."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1866",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.067",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1867",
              "shortDescription": {
                "text": "Use char overload"
              },
              "fullDescription": {
                "text": "The char overload is a better performing overload than a string with a single char."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1867",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.067",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1868",
              "shortDescription": {
                "text": "Unnecessary call to 'Contains(item)'"
              },
              "fullDescription": {
                "text": "Do not guard 'Add(item)' or 'Remove(item)' with 'Contains(item)' for the set. The former two already check whether the item exists and will return if it was added or removed."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1868",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1869",
              "shortDescription": {
                "text": "Cache and reuse 'JsonSerializerOptions' instances"
              },
              "fullDescription": {
                "text": "Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead. Single use 'JsonSerializerOptions' instances can substantially degrade the performance of your application."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1869",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA1870",
              "shortDescription": {
                "text": "Use a cached 'SearchValues' instance"
              },
              "fullDescription": {
                "text": "Using a cached 'SearchValues' instance is more efficient than passing values to 'IndexOfAny'/'ContainsAny' directly."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1870",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.023",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2000",
              "shortDescription": {
                "text": "Dispose objects before losing scope"
              },
              "fullDescription": {
                "text": "If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2000",
              "properties": {
                "category": "Reliability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2002",
              "shortDescription": {
                "text": "Do not lock on objects with weak identity"
              },
              "fullDescription": {
                "text": "An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2002",
              "properties": {
                "category": "Reliability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2007",
              "shortDescription": {
                "text": "Consider calling ConfigureAwait on the awaited task"
              },
              "fullDescription": {
                "text": "When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2007",
              "properties": {
                "category": "Reliability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2008",
              "shortDescription": {
                "text": "Do not create tasks without passing a TaskScheduler"
              },
              "fullDescription": {
                "text": "Do not create tasks unless you are using one of the overloads that takes a TaskScheduler. The default is to schedule on TaskScheduler.Current, which would lead to deadlocks. Either use TaskScheduler.Default to schedule on the thread pool, or explicitly pass TaskScheduler.Current to make your intentions clear."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2008",
              "properties": {
                "category": "Reliability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2009",
              "shortDescription": {
                "text": "Do not call ToImmutableCollection on an ImmutableCollection value"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2009",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2011",
              "shortDescription": {
                "text": "Avoid infinite recursion"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2011",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2012",
              "shortDescription": {
                "text": "Use ValueTasks correctly"
              },
              "fullDescription": {
                "text": "ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2012",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2013",
              "shortDescription": {
                "text": "Do not use ReferenceEquals with value types"
              },
              "fullDescription": {
                "text": "Value type typed arguments are uniquely boxed for each call to this method, therefore the result can be unexpected."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2013",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2014",
              "shortDescription": {
                "text": "Do not use stackalloc in loops"
              },
              "fullDescription": {
                "text": "Stack space allocated by a stackalloc is only released at the end of the current method's invocation.  Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2014",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2015",
              "shortDescription": {
                "text": "Do not define finalizers for types derived from MemoryManager<T>"
              },
              "fullDescription": {
                "text": "Adding a finalizer to a type derived from MemoryManager<T> may permit memory to be freed while it is still in use by a Span<T>."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2015",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2016",
              "shortDescription": {
                "text": "Forward the 'CancellationToken' parameter to methods"
              },
              "fullDescription": {
                "text": "Forward the 'CancellationToken' parameter to methods to ensure the operation cancellation notifications gets properly propagated, or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2016",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.018",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2017",
              "shortDescription": {
                "text": "Parameter count mismatch"
              },
              "fullDescription": {
                "text": "Number of parameters supplied in the logging message template do not match the number of named placeholders."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2017",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2018",
              "shortDescription": {
                "text": "'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument"
              },
              "fullDescription": {
                "text": "'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2018",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2019",
              "shortDescription": {
                "text": "Improper 'ThreadStatic' field initialization"
              },
              "fullDescription": {
                "text": "'ThreadStatic' fields should be initialized lazily on use, not with inline initialization nor explicitly in a static constructor, which would only initialize the field on the thread that runs the type's static constructor."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2019",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2020",
              "shortDescription": {
                "text": "Prevent behavioral change"
              },
              "fullDescription": {
                "text": "Some built-in operators added in .NET 7 behave differently when overflowing than did the corresponding user-defined operators in .NET 6 and earlier versions. Some operators that previously threw in an unchecked context now don't throw unless wrapped within a checked context. Also, some operators that did not previously throw in a checked context now throw unless wrapped in an unchecked context."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2020",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2021",
              "shortDescription": {
                "text": "Do not call Enumerable.Cast<T> or Enumerable.OfType<T> with incompatible types"
              },
              "fullDescription": {
                "text": "Enumerable.Cast<T> and Enumerable.OfType<T> require compatible types to function expectedly.  \u000d\u000aThe generic cast (IL 'unbox.any') used by the sequence returned by Enumerable.Cast<T> will throw InvalidCastException at runtime on elements of the types specified.  \u000d\u000aThe generic type check (C# 'is' operator/IL 'isinst') used by Enumerable.OfType<T> will never succeed with elements of types specified, resulting in an empty sequence.  \u000d\u000aWidening and user defined conversions are not supported with generic types."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2021",
              "properties": {
                "category": "Reliability",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2100",
              "shortDescription": {
                "text": "Review SQL queries for security vulnerabilities"
              },
              "fullDescription": {
                "text": "SQL queries that directly use user input can be vulnerable to SQL injection attacks. Review this SQL query for potential vulnerabilities, and consider using a parameterized SQL query."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2100",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2101",
              "shortDescription": {
                "text": "Specify marshaling for P/Invoke string arguments"
              },
              "fullDescription": {
                "text": "A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2101",
              "properties": {
                "category": "Globalization",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2119",
              "shortDescription": {
                "text": "Seal methods that satisfy private interfaces"
              },
              "fullDescription": {
                "text": "An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2119",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2153",
              "shortDescription": {
                "text": "Do Not Catch Corrupted State Exceptions"
              },
              "fullDescription": {
                "text": "Catching corrupted state exceptions could mask errors (such as access violations), resulting in inconsistent state of execution or making it easier for attackers to compromise system. Instead, catch and handle a more specific set of exception type(s) or re-throw the exception."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2153",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2200",
              "shortDescription": {
                "text": "Rethrow to preserve stack details"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2200",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2201",
              "shortDescription": {
                "text": "Do not raise reserved exception types"
              },
              "fullDescription": {
                "text": "An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2201",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2207",
              "shortDescription": {
                "text": "Initialize value type static fields inline"
              },
              "fullDescription": {
                "text": "A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2207",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2208",
              "shortDescription": {
                "text": "Instantiate argument exceptions correctly"
              },
              "fullDescription": {
                "text": "A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2208",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2211",
              "shortDescription": {
                "text": "Non-constant fields should not be visible"
              },
              "fullDescription": {
                "text": "Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2211",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2213",
              "shortDescription": {
                "text": "Disposable fields should be disposed"
              },
              "fullDescription": {
                "text": "A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2213",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2214",
              "shortDescription": {
                "text": "Do not call overridable methods in constructors"
              },
              "fullDescription": {
                "text": "Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2214",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2215",
              "shortDescription": {
                "text": "Dispose methods should call base class dispose"
              },
              "fullDescription": {
                "text": "A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2215",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2216",
              "shortDescription": {
                "text": "Disposable types should declare finalizer"
              },
              "fullDescription": {
                "text": "A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2216",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2217",
              "shortDescription": {
                "text": "Do not mark enums with FlagsAttribute"
              },
              "fullDescription": {
                "text": "An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2217",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2219",
              "shortDescription": {
                "text": "Do not raise exceptions in finally clauses"
              },
              "fullDescription": {
                "text": "When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2219",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2225",
              "shortDescription": {
                "text": "Operator overloads have named alternates"
              },
              "fullDescription": {
                "text": "An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2225",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2226",
              "shortDescription": {
                "text": "Operators should have symmetrical overloads"
              },
              "fullDescription": {
                "text": "A type implements the equality or inequality operator and does not implement the opposite operator."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2226",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2227",
              "shortDescription": {
                "text": "Collection properties should be read only"
              },
              "fullDescription": {
                "text": "A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2227",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2231",
              "shortDescription": {
                "text": "Overload operator equals on overriding value type Equals"
              },
              "fullDescription": {
                "text": "In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2231",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2234",
              "shortDescription": {
                "text": "Pass system uri objects instead of strings"
              },
              "fullDescription": {
                "text": "A call is made to a method that has a string parameter whose name contains \"uri\", \"URI\", \"urn\", \"URN\", \"url\", or \"URL\". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2234",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2235",
              "shortDescription": {
                "text": "Mark all non-serializable fields"
              },
              "fullDescription": {
                "text": "An instance field of a type that is not serializable is declared in a type that is serializable."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2235",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2237",
              "shortDescription": {
                "text": "Mark ISerializable types with serializable"
              },
              "fullDescription": {
                "text": "To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2237",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2241",
              "shortDescription": {
                "text": "Provide correct arguments to formatting methods"
              },
              "fullDescription": {
                "text": "The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2241",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.062",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2242",
              "shortDescription": {
                "text": "Test for NaN correctly"
              },
              "fullDescription": {
                "text": "This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2242",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2243",
              "shortDescription": {
                "text": "Attribute string literals should parse correctly"
              },
              "fullDescription": {
                "text": "The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2243",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "PortedFromFxCop",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2244",
              "shortDescription": {
                "text": "Do not duplicate indexed element initializations"
              },
              "fullDescription": {
                "text": "Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2244",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2245",
              "shortDescription": {
                "text": "Do not assign a property to itself"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2245",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2246",
              "shortDescription": {
                "text": "Assigning symbol and its member in the same statement"
              },
              "fullDescription": {
                "text": "Assigning to a symbol and its member (field/property) in the same statement is not recommended. It is not clear if the member access was intended to use symbol's old value prior to the assignment or new value from the assignment in this statement. For clarity, consider splitting the assignments into separate statements."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2246",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2247",
              "shortDescription": {
                "text": "Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum"
              },
              "fullDescription": {
                "text": "TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.  Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2247",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2248",
              "shortDescription": {
                "text": "Provide correct 'enum' argument to 'Enum.HasFlag'"
              },
              "fullDescription": {
                "text": "'Enum.HasFlag' method expects the 'enum' argument to be of the same 'enum' type as the instance on which the method is invoked and that this 'enum' is marked with 'System.FlagsAttribute'. If these are different 'enum' types, an unhandled exception will be thrown at runtime. If the 'enum' type is not marked with 'System.FlagsAttribute' the call will always return 'false' at runtime."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2248",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2249",
              "shortDescription": {
                "text": "Consider using 'string.Contains' instead of 'string.IndexOf'"
              },
              "fullDescription": {
                "text": "Calls to 'string.IndexOf' where the result is used to check for the presence/absence of a substring can be replaced by 'string.Contains'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2249",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.032",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2250",
              "shortDescription": {
                "text": "Use 'ThrowIfCancellationRequested'"
              },
              "fullDescription": {
                "text": "'ThrowIfCancellationRequested' automatically checks whether the token has been canceled, and throws an 'OperationCanceledException' if it has."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2250",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2251",
              "shortDescription": {
                "text": "Use 'string.Equals'"
              },
              "fullDescription": {
                "text": "It is both clearer and likely faster to use 'string.Equals' instead of comparing the result of 'string.Compare' to zero."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2251",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2252",
              "shortDescription": {
                "text": "This API requires opting into preview features"
              },
              "fullDescription": {
                "text": "An assembly has to opt into preview features before using them."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2252",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.080",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2253",
              "shortDescription": {
                "text": "Named placeholders should not be numeric values"
              },
              "fullDescription": {
                "text": "Named placeholders in the logging message template should not be comprised of only numeric characters."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2253",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2254",
              "shortDescription": {
                "text": "Template should be a static expression"
              },
              "fullDescription": {
                "text": "The logging message template should not vary between calls."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2254",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2255",
              "shortDescription": {
                "text": "The 'ModuleInitializer' attribute should not be used in libraries"
              },
              "fullDescription": {
                "text": "Module initializers are intended to be used by application code to ensure an application's components are initialized before the application code begins executing. If library code declares a method with the 'ModuleInitializerAttribute', it can interfere with application initialization and also lead to limitations in that application's trimming abilities. Instead of using methods marked with 'ModuleInitializerAttribute', the library should expose methods that can be used to initialize any components within the library and allow the application to invoke the method during application initialization."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2255",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2256",
              "shortDescription": {
                "text": "All members declared in parent interfaces must have an implementation in a DynamicInterfaceCastableImplementation-attributed interface"
              },
              "fullDescription": {
                "text": "Types attributed with 'DynamicInterfaceCastableImplementationAttribute' act as an interface implementation for a type that implements the 'IDynamicInterfaceCastable' type. As a result, it must provide an implementation of all of the members defined in the inherited interfaces, because the type that implements 'IDynamicInterfaceCastable' will not provide them otherwise."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2256",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2257",
              "shortDescription": {
                "text": "Members defined on an interface with the 'DynamicInterfaceCastableImplementationAttribute' should be 'static'"
              },
              "fullDescription": {
                "text": "Since a type that implements 'IDynamicInterfaceCastable' may not implement a dynamic interface in metadata, calls to an instance interface member that is not an explicit implementation defined on this type are likely to fail at runtime. Mark new interface members 'static' to avoid runtime errors."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2257",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2258",
              "shortDescription": {
                "text": "Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported"
              },
              "fullDescription": {
                "text": "Providing a functional 'DynamicInterfaceCastableImplementationAttribute'-attributed interface requires the Default Interface Members feature, which is unsupported in Visual Basic."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2258",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2259",
              "shortDescription": {
                "text": "'ThreadStatic' only affects static fields"
              },
              "fullDescription": {
                "text": "'ThreadStatic' only affects static fields. When applied to instance fields, it has no impact on behavior."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2259",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2260",
              "shortDescription": {
                "text": "Use correct type parameter"
              },
              "fullDescription": {
                "text": "Generic math interfaces require the derived type itself to be used for the self recurring type parameter."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2260",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2261",
              "shortDescription": {
                "text": "Do not use ConfigureAwaitOptions.SuppressThrowing with Task<TResult>"
              },
              "fullDescription": {
                "text": "The ConfigureAwaitOptions.SuppressThrowing is only supported with the non-generic Task, not a Task<TResult>.  To use it with a Task<TResult>, first cast to the base Task."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2261",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2300",
              "shortDescription": {
                "text": "Do not use insecure deserializer BinaryFormatter"
              },
              "fullDescription": {
                "text": "The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect BinaryFormatter deserialization without a SerializationBinder set, then disable rule CA2300, and enable rules CA2301 and CA2302."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2300",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2301",
              "shortDescription": {
                "text": "Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2301",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2302",
              "shortDescription": {
                "text": "Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2302",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2305",
              "shortDescription": {
                "text": "Do not use insecure deserializer LosFormatter"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2305",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2310",
              "shortDescription": {
                "text": "Do not use insecure deserializer NetDataContractSerializer"
              },
              "fullDescription": {
                "text": "The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect NetDataContractSerializer deserialization without a SerializationBinder set, then disable rule CA2310, and enable rules CA2311 and CA2312."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2310",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2311",
              "shortDescription": {
                "text": "Do not deserialize without first setting NetDataContractSerializer.Binder"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2311",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2312",
              "shortDescription": {
                "text": "Ensure NetDataContractSerializer.Binder is set before deserializing"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2312",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2315",
              "shortDescription": {
                "text": "Do not use insecure deserializer ObjectStateFormatter"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2315",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2321",
              "shortDescription": {
                "text": "Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2321",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2322",
              "shortDescription": {
                "text": "Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2322",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2326",
              "shortDescription": {
                "text": "Do not use TypeNameHandling values other than None"
              },
              "fullDescription": {
                "text": "Deserializing JSON when using a TypeNameHandling value other than None can be insecure.  If you need to instead detect Json.NET deserialization when a SerializationBinder isn't specified, then disable rule CA2326, and enable rules CA2327, CA2328, CA2329, and CA2330."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2326",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2327",
              "shortDescription": {
                "text": "Do not use insecure JsonSerializerSettings"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2327",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2328",
              "shortDescription": {
                "text": "Ensure that JsonSerializerSettings are secure"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2328",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2329",
              "shortDescription": {
                "text": "Do not deserialize with JsonSerializer using an insecure configuration"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2329",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2330",
              "shortDescription": {
                "text": "Ensure that JsonSerializer has a secure configuration when deserializing"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2330",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA2350",
              "shortDescription": {
                "text": "Do not use DataTable.ReadXml() with untrusted data"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2350",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2351",
              "shortDescription": {
                "text": "Do not use DataSet.ReadXml() with untrusted data"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2351",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2352",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2352",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2353",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable in serializable type"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2353",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2354",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attacks"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2354",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2355",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable type found in deserializable object graph"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2355",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2356",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable type in web deserializable object graph"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2356",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2361",
              "shortDescription": {
                "text": "Ensure auto-generated class containing DataSet.ReadXml() is not used with untrusted data"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2361",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA2362",
              "shortDescription": {
                "text": "Unsafe DataSet or DataTable in auto-generated serializable type can be vulnerable to remote code execution attacks"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2362",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3001",
              "shortDescription": {
                "text": "Review code for SQL injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3001",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3002",
              "shortDescription": {
                "text": "Review code for XSS vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3002",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3003",
              "shortDescription": {
                "text": "Review code for file path injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3003",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3004",
              "shortDescription": {
                "text": "Review code for information disclosure vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3004",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3005",
              "shortDescription": {
                "text": "Review code for LDAP injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3005",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3006",
              "shortDescription": {
                "text": "Review code for process command injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3006",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3007",
              "shortDescription": {
                "text": "Review code for open redirect vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3007",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3008",
              "shortDescription": {
                "text": "Review code for XPath injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3008",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3009",
              "shortDescription": {
                "text": "Review code for XML injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3009",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3010",
              "shortDescription": {
                "text": "Review code for XAML injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3010",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3011",
              "shortDescription": {
                "text": "Review code for DLL injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3011",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3012",
              "shortDescription": {
                "text": "Review code for regex injection vulnerabilities"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3012",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3061",
              "shortDescription": {
                "text": "Do Not Add Schema By URL"
              },
              "fullDescription": {
                "text": "This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3061",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3075",
              "shortDescription": {
                "text": "Insecure DTD processing in XML"
              },
              "fullDescription": {
                "text": "Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3075",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3076",
              "shortDescription": {
                "text": "Insecure XSLT script processing"
              },
              "fullDescription": {
                "text": "Providing an insecure XsltSettings instance and an insecure XmlResolver instance to XslCompiledTransform.Load method is potentially unsafe as it allows processing script within XSL, which on an untrusted XSL input may lead to malicious code execution. Either replace the insecure XsltSettings argument with XsltSettings.Default or an instance that has disabled document function and script execution, or replace the XmlResolver argument with null or an XmlSecureResolver instance. This message may be suppressed if the input is known to be from a trusted source and external resource resolution from locations that are not known in advance must be supported."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3076",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3077",
              "shortDescription": {
                "text": "Insecure Processing in API Design, XmlDocument and XmlTextReader"
              },
              "fullDescription": {
                "text": "Enabling DTD processing on all instances derived from XmlTextReader or  XmlDocument and using XmlUrlResolver for resolving external XML entities may lead to information disclosure. Ensure to set the XmlResolver property to null, create an instance of XmlSecureResolver when processing untrusted input, or use XmlReader.Create method with a secure XmlReaderSettings argument. Unless you need to enable it, ensure the DtdProcessing property is set to false."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3077",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA3147",
              "shortDescription": {
                "text": "Mark Verb Handlers With Validate Antiforgery Token"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca3147",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5350",
              "shortDescription": {
                "text": "Do Not Use Weak Cryptographic Algorithms"
              },
              "fullDescription": {
                "text": "Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5350",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5351",
              "shortDescription": {
                "text": "Do Not Use Broken Cryptographic Algorithms"
              },
              "fullDescription": {
                "text": "An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5351",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5358",
              "shortDescription": {
                "text": "Review cipher mode usage with cryptography experts"
              },
              "fullDescription": {
                "text": "These cipher modes might be vulnerable to attacks. Consider using recommended modes (CBC, CTS)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5358",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5359",
              "shortDescription": {
                "text": "Do Not Disable Certificate Validation"
              },
              "fullDescription": {
                "text": "A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5359",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5360",
              "shortDescription": {
                "text": "Do Not Call Dangerous Methods In Deserialization"
              },
              "fullDescription": {
                "text": "Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5360",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5361",
              "shortDescription": {
                "text": "Do Not Disable SChannel Use of Strong Crypto"
              },
              "fullDescription": {
                "text": "Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommended to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5361",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5362",
              "shortDescription": {
                "text": "Potential reference cycle in deserialized object graph"
              },
              "fullDescription": {
                "text": "Review code that processes untrusted deserialized data for handling of unexpected reference cycles. An unexpected reference cycle should not cause the code to enter an infinite loop. Otherwise, an unexpected reference cycle can allow an attacker to DOS or exhaust the memory of the process when deserializing untrusted data."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5362",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5363",
              "shortDescription": {
                "text": "Do Not Disable Request Validation"
              },
              "fullDescription": {
                "text": "Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5363",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5364",
              "shortDescription": {
                "text": "Do Not Use Deprecated Security Protocols"
              },
              "fullDescription": {
                "text": "Using a deprecated security protocol rather than the system default is risky."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5364",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5365",
              "shortDescription": {
                "text": "Do Not Disable HTTP Header Checking"
              },
              "fullDescription": {
                "text": "HTTP header checking enables encoding of the carriage return and newline characters, \\r and \\n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5365",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5366",
              "shortDescription": {
                "text": "Use XmlReader for 'DataSet.ReadXml()'"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5366",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5367",
              "shortDescription": {
                "text": "Do Not Serialize Types With Pointer Fields"
              },
              "fullDescription": {
                "text": "Pointers are not \"type safe\" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5367",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5368",
              "shortDescription": {
                "text": "Set ViewStateUserKey For Classes Derived From Page"
              },
              "fullDescription": {
                "text": "Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5368",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5369",
              "shortDescription": {
                "text": "Use XmlReader for 'XmlSerializer.Deserialize()'"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5369",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5370",
              "shortDescription": {
                "text": "Use XmlReader for XmlValidatingReader constructor"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5370",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5371",
              "shortDescription": {
                "text": "Use XmlReader for 'XmlSchema.Read()'"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5371",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5372",
              "shortDescription": {
                "text": "Use XmlReader for XPathDocument constructor"
              },
              "fullDescription": {
                "text": "Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5372",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5373",
              "shortDescription": {
                "text": "Do not use obsolete key derivation function"
              },
              "fullDescription": {
                "text": "Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5373",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5374",
              "shortDescription": {
                "text": "Do Not Use XslTransform"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5374",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5375",
              "shortDescription": {
                "text": "Do Not Use Account Shared Access Signature"
              },
              "fullDescription": {
                "text": "Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5375",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5376",
              "shortDescription": {
                "text": "Use SharedAccessProtocol HttpsOnly"
              },
              "fullDescription": {
                "text": "HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5376",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5377",
              "shortDescription": {
                "text": "Use Container Level Access Policy"
              },
              "fullDescription": {
                "text": "No access policy identifier is specified, making tokens non-revocable."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5377",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5378",
              "shortDescription": {
                "text": "Do not disable ServicePointManagerSecurityProtocols"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5378",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5379",
              "shortDescription": {
                "text": "Ensure Key Derivation Function algorithm is sufficiently strong"
              },
              "fullDescription": {
                "text": "Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5379",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5380",
              "shortDescription": {
                "text": "Do Not Add Certificates To Root Store"
              },
              "fullDescription": {
                "text": "By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5380",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5381",
              "shortDescription": {
                "text": "Ensure Certificates Are Not Added To Root Store"
              },
              "fullDescription": {
                "text": "By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5381",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5382",
              "shortDescription": {
                "text": "Use Secure Cookies In ASP.NET Core"
              },
              "fullDescription": {
                "text": "Applications available over HTTPS must use secure cookies."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5382",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5383",
              "shortDescription": {
                "text": "Ensure Use Secure Cookies In ASP.NET Core"
              },
              "fullDescription": {
                "text": "Applications available over HTTPS must use secure cookies."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5383",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5384",
              "shortDescription": {
                "text": "Do Not Use Digital Signature Algorithm (DSA)"
              },
              "fullDescription": {
                "text": "DSA is too weak to use."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5384",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5385",
              "shortDescription": {
                "text": "Use Rivest-Shamir-Adleman (RSA) Algorithm With Sufficient Key Size"
              },
              "fullDescription": {
                "text": "Encryption algorithms are vulnerable to brute force attacks when too small a key size is used."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5385",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5386",
              "shortDescription": {
                "text": "Avoid hardcoding SecurityProtocolType value"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5386",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5387",
              "shortDescription": {
                "text": "Do Not Use Weak Key Derivation Function With Insufficient Iteration Count"
              },
              "fullDescription": {
                "text": "When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5387",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5388",
              "shortDescription": {
                "text": "Ensure Sufficient Iteration Count When Using Weak Key Derivation Function"
              },
              "fullDescription": {
                "text": "When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5388",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5389",
              "shortDescription": {
                "text": "Do Not Add Archive Item's Path To The Target File System Path"
              },
              "fullDescription": {
                "text": "When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5389",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5390",
              "shortDescription": {
                "text": "Do not hard-code encryption key"
              },
              "fullDescription": {
                "text": "SymmetricAlgorithm's .Key property, or a method's rgbKey parameter, should never be a hard-coded value."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5390",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5391",
              "shortDescription": {
                "text": "Use antiforgery tokens in ASP.NET Core MVC controllers"
              },
              "fullDescription": {
                "text": "Handling a POST, PUT, PATCH, or DELETE request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks. A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5391",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5392",
              "shortDescription": {
                "text": "Use DefaultDllImportSearchPaths attribute for P/Invokes"
              },
              "fullDescription": {
                "text": "By default, P/Invokes using DllImportAttribute probe a number of directories, including the current working directory for the library to load. This can be a security issue for certain applications, leading to DLL hijacking."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5392",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5393",
              "shortDescription": {
                "text": "Do not use unsafe DllImportSearchPath value"
              },
              "fullDescription": {
                "text": "There could be a malicious DLL in the default DLL search directories. Or, depending on where your application is run from, there could be a malicious DLL in the application's directory. Use a DllImportSearchPath value that specifies an explicit search path instead. The DllImportSearchPath flags that this rule looks for can be configured in .editorconfig."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5393",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5394",
              "shortDescription": {
                "text": "Do not use insecure randomness"
              },
              "fullDescription": {
                "text": "Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated. Use a cryptographically strong random number generator if an unpredictable value is required, or ensure that weak pseudo-random numbers aren't used in a security-sensitive manner."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5394",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5395",
              "shortDescription": {
                "text": "Miss HttpVerb attribute for action methods"
              },
              "fullDescription": {
                "text": "All the methods that create, edit, delete, or otherwise modify data do so in the [HttpPost] overload of the method, which needs to be protected with the anti forgery attribute from request forgery. Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5395",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5396",
              "shortDescription": {
                "text": "Set HttpOnly to true for HttpCookie"
              },
              "fullDescription": {
                "text": "As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5396",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5397",
              "shortDescription": {
                "text": "Do not use deprecated SslProtocols values"
              },
              "fullDescription": {
                "text": "Older protocol versions of Transport Layer Security (TLS) are less secure than TLS 1.2 and TLS 1.3, and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5397",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5398",
              "shortDescription": {
                "text": "Avoid hardcoded SslProtocols values"
              },
              "fullDescription": {
                "text": "Current Transport Layer Security protocol versions may become deprecated if vulnerabilities are found. Avoid hardcoding SslProtocols values to keep your application secure. Use 'None' to let the Operating System choose a version."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5398",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5399",
              "shortDescription": {
                "text": "HttpClients should enable certificate revocation list checks"
              },
              "fullDescription": {
                "text": "Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5399",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5400",
              "shortDescription": {
                "text": "Ensure HttpClient certificate revocation list check is not disabled"
              },
              "fullDescription": {
                "text": "Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5400",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5401",
              "shortDescription": {
                "text": "Do not use CreateEncryptor with non-default IV"
              },
              "fullDescription": {
                "text": "Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5401",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5402",
              "shortDescription": {
                "text": "Use CreateEncryptor with the default IV "
              },
              "fullDescription": {
                "text": "Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5402",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode",
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "CA5403",
              "shortDescription": {
                "text": "Do not hard-code certificate"
              },
              "fullDescription": {
                "text": "Hard-coded certificates in source code are vulnerable to being exploited."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5403",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Dataflow",
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5404",
              "shortDescription": {
                "text": "Do not disable token validation checks"
              },
              "fullDescription": {
                "text": "Token validation checks ensure that while validating tokens, all aspects are analyzed and verified. Turning off validation can lead to security holes by allowing untrusted tokens to make it through validation."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5404",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "CA5405",
              "shortDescription": {
                "text": "Do not always skip token validation in delegates"
              },
              "fullDescription": {
                "text": "By setting critical TokenValidationParameter validation delegates to true, important authentication safeguards are disabled which can lead to tokens from any issuer or expired tokens being wrongly validated."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca5405",
              "properties": {
                "category": "Security",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnabledRuleInAggressiveMode"
                ]
              }
            },
            {
              "id": "EnableGenerateDocumentationFile",
              "shortDescription": {
                "text": "Set MSBuild property 'GenerateDocumentationFile' to 'true'"
              },
              "fullDescription": {
                "text": "Add the following PropertyGroup to your MSBuild project file to enable IDE0005 (Remove unnecessary usings/imports) on build:\u000d\u000a  <PropertyGroup>\u000d\u000a    <!--\u000d\u000a      Make sure any documentation comments which are included in code get checked for syntax during the build, but do\u000d\u000a      not report warnings for missing comments.\u000d\u000a      CS1573: Parameter 'parameter' has no matching param tag in the XML comment for 'parameter' (but other parameters do)\u000d\u000a      CS1591: Missing XML comment for publicly visible type or member 'Type_or_Member'\u000d\u000a      CS1712: Type parameter 'type_parameter' has no matching typeparam tag in the XML comment on 'type_or_member' (but other type parameters do)\u000d\u000a    -->\u000d\u000a    <GenerateDocumentationFile>True</GenerateDocumentationFile>\u000d\u000a    <NoWarn>$(NoWarn),1573,1591,1712</NoWarn>\u000d\u000a  </PropertyGroup>\u000d\u000a    "
              },
              "helpUri": "https://github.com/dotnet/roslyn/issues/41640",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.136",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Never"
                ]
              }
            },
            {
              "id": "IDE0004",
              "shortDescription": {
                "text": "Remove Unnecessary Cast"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0004",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0005",
              "shortDescription": {
                "text": "Using directive is unnecessary."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0005",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.136",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0005_gen",
              "shortDescription": {
                "text": "Using directive is unnecessary."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "0.136",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Never",
                  "NotConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0007",
              "shortDescription": {
                "text": "Use implicit type"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0007",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.112",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0008",
              "shortDescription": {
                "text": "Use explicit type"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0008",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0009",
              "shortDescription": {
                "text": "Member access should be qualified."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0009",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Never",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0010",
              "shortDescription": {
                "text": "Add missing cases"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0010",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0011",
              "shortDescription": {
                "text": "Add braces"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0011",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0016",
              "shortDescription": {
                "text": "Use 'throw' expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0016",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0017",
              "shortDescription": {
                "text": "Simplify object initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0017",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0018",
              "shortDescription": {
                "text": "Inline variable declaration"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0018",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.052",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0019",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0019",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0020",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0020",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0021",
              "shortDescription": {
                "text": "Use expression body for constructor"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0021",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.795",
                "executionTimeInPercentage": "5",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0022",
              "shortDescription": {
                "text": "Use expression body for method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0022",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.795",
                "executionTimeInPercentage": "5",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0023",
              "shortDescription": {
                "text": "Use expression body for conversion operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0023",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.795",
                "executionTimeInPercentage": "5",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0024",
              "shortDescription": {
                "text": "Use expression body for operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0024",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.795",
                "executionTimeInPercentage": "5",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0025",
              "shortDescription": {
                "text": "Use expression body for property"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0025",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.795",
                "executionTimeInPercentage": "5",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0026",
              "shortDescription": {
                "text": "Use expression body for indexer"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0026",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.795",
                "executionTimeInPercentage": "5",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0027",
              "shortDescription": {
                "text": "Use expression body for accessor"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0027",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.795",
                "executionTimeInPercentage": "5",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0028",
              "shortDescription": {
                "text": "Simplify collection initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0028",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.051",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0029",
              "shortDescription": {
                "text": "Use coalesce expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0029",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0030",
              "shortDescription": {
                "text": "Use coalesce expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0030",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0031",
              "shortDescription": {
                "text": "Use null propagation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0031",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.020",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0032",
              "shortDescription": {
                "text": "Use auto property"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0032",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.017",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0033",
              "shortDescription": {
                "text": "Use explicitly provided tuple name"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0033",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0034",
              "shortDescription": {
                "text": "Simplify 'default' expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0034",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0035",
              "shortDescription": {
                "text": "Unreachable code detected"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0035",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Never",
                  "NotConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0036",
              "shortDescription": {
                "text": "Order modifiers"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0036",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0037",
              "shortDescription": {
                "text": "Use inferred member name"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0037",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0039",
              "shortDescription": {
                "text": "Use local function"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0039",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0040",
              "shortDescription": {
                "text": "Add accessibility modifiers"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0040",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.022",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0041",
              "shortDescription": {
                "text": "Use 'is null' check"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0041",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0042",
              "shortDescription": {
                "text": "Deconstruct variable declaration"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0042",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0043",
              "shortDescription": {
                "text": "Invalid format string"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Compiler",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0044",
              "shortDescription": {
                "text": "Add readonly modifier"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0044",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0045",
              "shortDescription": {
                "text": "Convert to conditional expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0045",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0046",
              "shortDescription": {
                "text": "Convert to conditional expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0046",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0047",
              "shortDescription": {
                "text": "Remove unnecessary parentheses"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0047",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.027",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0048",
              "shortDescription": {
                "text": "Add parentheses for clarity"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0048",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0051",
              "shortDescription": {
                "text": "Remove unused private members"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0051",
              "properties": {
                "category": "CodeQuality",
                "executionTimeInSeconds": "0.063",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0052",
              "shortDescription": {
                "text": "Remove unread private members"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0052",
              "properties": {
                "category": "CodeQuality",
                "executionTimeInSeconds": "0.063",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0053",
              "shortDescription": {
                "text": "Use expression body for lambda expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0053",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0054",
              "shortDescription": {
                "text": "Use compound assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0054",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0055",
              "shortDescription": {
                "text": "Fix formatting"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0055",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0056",
              "shortDescription": {
                "text": "Use index operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0056",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0057",
              "shortDescription": {
                "text": "Use range operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0057",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0058",
              "shortDescription": {
                "text": "Expression value is never used"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0058",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.484",
                "executionTimeInPercentage": "3",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0059",
              "shortDescription": {
                "text": "Unnecessary assignment of a value"
              },
              "fullDescription": {
                "text": "Avoid unnecessary value assignments in your code, as these likely indicate redundant value computations. If the value computation is not redundant and you intend to retain the assignment, then change the assignment target to a local variable whose name starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0059",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.484",
                "executionTimeInPercentage": "3",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0060",
              "shortDescription": {
                "text": "Remove unused parameter"
              },
              "fullDescription": {
                "text": "Avoid unused parameters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0060",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.484",
                "executionTimeInPercentage": "3",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0061",
              "shortDescription": {
                "text": "Use expression body for local function"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0061",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.795",
                "executionTimeInPercentage": "5",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0062",
              "shortDescription": {
                "text": "Make local function 'static'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0062",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0063",
              "shortDescription": {
                "text": "Use simple 'using' statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0063",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0064",
              "shortDescription": {
                "text": "Make readonly fields writable"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0064",
              "properties": {
                "category": "CodeQuality",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0065",
              "shortDescription": {
                "text": "Misplaced using directive"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0065",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0066",
              "shortDescription": {
                "text": "Convert switch statement to expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0066",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0070",
              "shortDescription": {
                "text": "Use 'System.HashCode'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0070",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0071",
              "shortDescription": {
                "text": "Simplify interpolation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0071",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0072",
              "shortDescription": {
                "text": "Add missing cases"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0072",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0073",
              "shortDescription": {
                "text": "The file header does not match the required text"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0073",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0074",
              "shortDescription": {
                "text": "Use compound assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0074",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.023",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0075",
              "shortDescription": {
                "text": "Simplify conditional expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0075",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0076",
              "shortDescription": {
                "text": "Invalid global 'SuppressMessageAttribute'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0076",
              "properties": {
                "category": "CodeQuality",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0077",
              "shortDescription": {
                "text": "Avoid legacy format target in 'SuppressMessageAttribute'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0077",
              "properties": {
                "category": "CodeQuality",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0078",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0078",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0080",
              "shortDescription": {
                "text": "Remove unnecessary suppression operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0080",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended"
                ]
              }
            },
            {
              "id": "IDE0082",
              "shortDescription": {
                "text": "'typeof' can be converted to 'nameof'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0082",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0083",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0083",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0090",
              "shortDescription": {
                "text": "Use 'new(...)'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0090",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0100",
              "shortDescription": {
                "text": "Remove redundant equality"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0100",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0110",
              "shortDescription": {
                "text": "Remove unnecessary discard"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0110",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0120",
              "shortDescription": {
                "text": "Simplify LINQ expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0120",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled"
                ]
              }
            },
            {
              "id": "IDE0130",
              "shortDescription": {
                "text": "Namespace does not match folder structure"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0130",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0150",
              "shortDescription": {
                "text": "Prefer 'null' check over type check"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0150",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0160",
              "shortDescription": {
                "text": "Convert to block scoped namespace"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0160",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0161",
              "shortDescription": {
                "text": "Convert to file-scoped namespace"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0161",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0170",
              "shortDescription": {
                "text": "Property pattern can be simplified"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0170",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0180",
              "shortDescription": {
                "text": "Use tuple to swap values"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0180",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.017",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_HighlyRecommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0200",
              "shortDescription": {
                "text": "Remove unnecessary lambda expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0200",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0210",
              "shortDescription": {
                "text": "Convert to top-level statements"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0210",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0211",
              "shortDescription": {
                "text": "Convert to 'Program.Main' style program"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0211",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0220",
              "shortDescription": {
                "text": "Add explicit cast"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0220",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.023",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0230",
              "shortDescription": {
                "text": "Use UTF-8 string literal"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0230",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0240",
              "shortDescription": {
                "text": "Remove redundant nullable directive"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0240",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0241",
              "shortDescription": {
                "text": "Remove unnecessary nullable directive"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0241",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "IDE0250",
              "shortDescription": {
                "text": "Make struct 'readonly'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0250",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0251",
              "shortDescription": {
                "text": "Make member 'readonly'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0251",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0260",
              "shortDescription": {
                "text": "Use pattern matching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0260",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0270",
              "shortDescription": {
                "text": "Use coalesce expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0270",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0280",
              "shortDescription": {
                "text": "Use 'nameof'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0280",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE0290",
              "shortDescription": {
                "text": "Use primary constructor"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0290",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0300",
              "shortDescription": {
                "text": "Simplify collection initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0300",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0301",
              "shortDescription": {
                "text": "Simplify collection initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0301",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0302",
              "shortDescription": {
                "text": "Simplify collection initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0302",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0303",
              "shortDescription": {
                "text": "Simplify collection initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0303",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.042",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0304",
              "shortDescription": {
                "text": "Simplify collection initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0304",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.022",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE0305",
              "shortDescription": {
                "text": "Simplify collection initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0305",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE1005",
              "shortDescription": {
                "text": "Delegate invocation can be simplified."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide1005",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE1006",
              "shortDescription": {
                "text": "Naming Styles"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide1006",
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Recommended"
                ]
              }
            },
            {
              "id": "IDE2000",
              "shortDescription": {
                "text": "Avoid multiple blank lines"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2000",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE2001",
              "shortDescription": {
                "text": "Embedded statements must be on their own line"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2001",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE2002",
              "shortDescription": {
                "text": "Consecutive braces must not have blank line between them"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2002",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE2003",
              "shortDescription": {
                "text": "Blank line required between block and subsequent statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2003",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE2004",
              "shortDescription": {
                "text": "Blank line not allowed after constructor initializer colon"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2004",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE2005",
              "shortDescription": {
                "text": "Blank line not allowed after conditional expression token"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2005",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "IDE2006",
              "shortDescription": {
                "text": "Blank line not allowed after arrow expression clause token"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2006",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_WhenExplicitlyEnabled",
                  "CustomSeverityConfigurable"
                ]
              }
            },
            {
              "id": "MA0001",
              "shortDescription": {
                "text": "StringComparison is missing"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0001.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.018",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0002",
              "shortDescription": {
                "text": "IEqualityComparer<string> or IComparer<string> is missing"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0002.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.072",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0003",
              "shortDescription": {
                "text": "Add parameter name to improve readability"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0003.md",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.043",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0004",
              "shortDescription": {
                "text": "Use Task.ConfigureAwait"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0004.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0005",
              "shortDescription": {
                "text": "Use Array.Empty<T>()"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0005.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0006",
              "shortDescription": {
                "text": "Use String.Equals instead of equality operator"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0006.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0007",
              "shortDescription": {
                "text": "Add a comma after the last value"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0007.md",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0008",
              "shortDescription": {
                "text": "Add StructLayoutAttribute"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0008.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0009",
              "shortDescription": {
                "text": "Add regex evaluation timeout"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0009.md",
              "properties": {
                "category": "Security",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0010",
              "shortDescription": {
                "text": "Mark attributes with AttributeUsageAttribute"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0010.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0011",
              "shortDescription": {
                "text": "IFormatProvider is missing"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0011.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.067",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0012",
              "shortDescription": {
                "text": "Do not raise reserved exception type"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0012.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0013",
              "shortDescription": {
                "text": "Types should not extend System.ApplicationException"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0013.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0014",
              "shortDescription": {
                "text": "Do not raise System.ApplicationException type"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0014.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0015",
              "shortDescription": {
                "text": "Specify the parameter name in ArgumentException"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0015.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0016",
              "shortDescription": {
                "text": "Prefer using collection abstraction instead of implementation"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0016.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.042",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0017",
              "shortDescription": {
                "text": "Abstract types should not have public or internal constructors"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0017.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0018",
              "shortDescription": {
                "text": "Do not declare static members on generic types (deprecated; use CA1000 instead)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0018.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0019",
              "shortDescription": {
                "text": "Use EventArgs.Empty"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0019.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0020",
              "shortDescription": {
                "text": "Use direct methods instead of LINQ methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0020.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.172",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "MA0021",
              "shortDescription": {
                "text": "Use StringComparer.GetHashCode instead of string.GetHashCode"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0021.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0022",
              "shortDescription": {
                "text": "Return Task.FromResult instead of returning null"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0022.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0023",
              "shortDescription": {
                "text": "Add RegexOptions.ExplicitCapture"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0023.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0024",
              "shortDescription": {
                "text": "Use an explicit StringComparer when possible"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0024.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0025",
              "shortDescription": {
                "text": "Implement the functionality instead of throwing NotImplementedException"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0025.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0026",
              "shortDescription": {
                "text": "Fix TODO comment"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0026.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.022",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0027",
              "shortDescription": {
                "text": "Prefer rethrowing an exception implicitly"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0027.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0028",
              "shortDescription": {
                "text": "Optimize StringBuilder usage"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0028.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0029",
              "shortDescription": {
                "text": "Combine LINQ methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0029.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.172",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "MA0030",
              "shortDescription": {
                "text": "Remove useless OrderBy call"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0030.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.172",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "MA0031",
              "shortDescription": {
                "text": "Optimize Enumerable.Count() usage"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0031.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.172",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "MA0032",
              "shortDescription": {
                "text": "Use an overload with a CancellationToken argument"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0032.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "0.098",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0033",
              "shortDescription": {
                "text": "Do not tag instance fields with ThreadStaticAttribute"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0033.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0035",
              "shortDescription": {
                "text": "Do not use dangerous threading methods"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0035.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0036",
              "shortDescription": {
                "text": "Make class static"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0036.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0037",
              "shortDescription": {
                "text": "Remove empty statement"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0037.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0038",
              "shortDescription": {
                "text": "Make method static (deprecated, use CA1822 instead)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0038.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.064",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0039",
              "shortDescription": {
                "text": "Do not write your own certificate validation method"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0039.md",
              "properties": {
                "category": "Security",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0040",
              "shortDescription": {
                "text": "Forward the CancellationToken parameter to methods that take one"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0040.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.098",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0041",
              "shortDescription": {
                "text": "Make property static (deprecated, use CA1822 instead)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0041.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.064",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0042",
              "shortDescription": {
                "text": "Do not use blocking calls in an async method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0042.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.085",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0043",
              "shortDescription": {
                "text": "Use nameof operator in ArgumentException"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0043.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0044",
              "shortDescription": {
                "text": "Remove useless ToString call"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0044.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0045",
              "shortDescription": {
                "text": "Do not use blocking calls in a sync method (need to make calling method async)"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0045.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.085",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0046",
              "shortDescription": {
                "text": "Use EventHandler<T> to declare events"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0046.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0047",
              "shortDescription": {
                "text": "Declare types in namespaces"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0047.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0048",
              "shortDescription": {
                "text": "File name must match type name"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0048.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.036",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0049",
              "shortDescription": {
                "text": "Type name should not match containing namespace"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0049.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0050",
              "shortDescription": {
                "text": "Validate arguments correctly in iterator methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0050.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.034",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0051",
              "shortDescription": {
                "text": "Method is too long"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0051.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.089",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0052",
              "shortDescription": {
                "text": "Replace constant Enum.ToString with nameof"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0052.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0053",
              "shortDescription": {
                "text": "Make class sealed"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0053.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0054",
              "shortDescription": {
                "text": "Embed the caught exception as innerException"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0054.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0055",
              "shortDescription": {
                "text": "Do not use finalizer"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0055.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0056",
              "shortDescription": {
                "text": "Do not call overridable members in constructor"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0056.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0057",
              "shortDescription": {
                "text": "Class name should end with 'Attribute'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0057.md",
              "properties": {
                "category": "Naming",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0058",
              "shortDescription": {
                "text": "Class name should end with 'Exception'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0058.md",
              "properties": {
                "category": "Naming",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0059",
              "shortDescription": {
                "text": "Class name should end with 'EventArgs'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0059.md",
              "properties": {
                "category": "Naming",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0060",
              "shortDescription": {
                "text": "The value returned by Stream.Read/Stream.ReadAsync is not used"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0060.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0061",
              "shortDescription": {
                "text": "Method overrides should not change default values"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0061.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0062",
              "shortDescription": {
                "text": "Non-flags enums should not be marked with \"FlagsAttribute\""
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0062.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0063",
              "shortDescription": {
                "text": "Use Where before OrderBy"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0063.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.172",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "MA0064",
              "shortDescription": {
                "text": "Avoid locking on publicly accessible instance"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0064.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0065",
              "shortDescription": {
                "text": "Default ValueType.Equals or HashCode is used for struct equality"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0065.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0066",
              "shortDescription": {
                "text": "Hash table unfriendly type is used in a hash table"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0066.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0067",
              "shortDescription": {
                "text": "Use Guid.Empty"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0067.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0068",
              "shortDescription": {
                "text": "Invalid parameter name for nullable attribute"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0068.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0069",
              "shortDescription": {
                "text": "Non-constant static fields should not be visible"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0069.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0070",
              "shortDescription": {
                "text": "Obsolete attributes should include explanations"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0070.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0071",
              "shortDescription": {
                "text": "Avoid using redundant else"
              },
              "fullDescription": {
                "text": "The 'if' block contains a jump statement (break, continue, goto, return, throw, yield break). Using 'else' is redundant and needlessly maintains a higher nesting level."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0071.md",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0072",
              "shortDescription": {
                "text": "Do not throw from a finally block"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0072.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0073",
              "shortDescription": {
                "text": "Avoid comparison with bool constant"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0073.md",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0074",
              "shortDescription": {
                "text": "Avoid implicit culture-sensitive methods"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0074.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.018",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0075",
              "shortDescription": {
                "text": "Do not use implicit culture-sensitive ToString"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0075.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0076",
              "shortDescription": {
                "text": "Do not use implicit culture-sensitive ToString in interpolated strings"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0076.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0077",
              "shortDescription": {
                "text": "A class that provides Equals(T) should implement IEquatable<T>"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0077.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0078",
              "shortDescription": {
                "text": "Use 'Cast' instead of 'Select' to cast"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0078.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.172",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "MA0079",
              "shortDescription": {
                "text": "Forward the CancellationToken using .WithCancellation()"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0079.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.098",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0080",
              "shortDescription": {
                "text": "Use a cancellation token using .WithCancellation()"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0080.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.098",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0081",
              "shortDescription": {
                "text": "Method overrides should not omit params keyword"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0081.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0082",
              "shortDescription": {
                "text": "NaN should not be used in comparisons"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0082.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0083",
              "shortDescription": {
                "text": "ConstructorArgument parameters should exist in constructors"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0083.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0084",
              "shortDescription": {
                "text": "Local variables should not hide other symbols"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0084.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0085",
              "shortDescription": {
                "text": "Anonymous delegates should not be used to unsubscribe from Events"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0085.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0086",
              "shortDescription": {
                "text": "Do not throw from a finalizer"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0086.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0087",
              "shortDescription": {
                "text": "Parameters with [DefaultParameterValue] attributes should also be marked [Optional]"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0087.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0088",
              "shortDescription": {
                "text": "Use [DefaultParameterValue] instead of [DefaultValue]"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0088.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0089",
              "shortDescription": {
                "text": "Optimize string method usage"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0089.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.104",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0090",
              "shortDescription": {
                "text": "Remove empty else/finally block"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0090.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0091",
              "shortDescription": {
                "text": "Sender should be 'this' for instance events"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0091.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0092",
              "shortDescription": {
                "text": "Sender should be 'null' for static events"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0092.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0093",
              "shortDescription": {
                "text": "EventArgs should not be null"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0093.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0094",
              "shortDescription": {
                "text": "A class that provides CompareTo(T) should implement IComparable<T>"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0094.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0095",
              "shortDescription": {
                "text": "A class that implements IEquatable<T> should override Equals(object)"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0095.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0096",
              "shortDescription": {
                "text": "A class that implements IComparable<T> should also implement IEquatable<T>"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0096.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0097",
              "shortDescription": {
                "text": "A class that implements IComparable<T> or IComparable should override comparison operators"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0097.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0098",
              "shortDescription": {
                "text": "Use indexer instead of LINQ methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0098.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.172",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "MA0099",
              "shortDescription": {
                "text": "Use Explicit enum value instead of 0"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0099.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0100",
              "shortDescription": {
                "text": "Await task before disposing of resources"
              },
              "fullDescription": {
                "text": "Await the task before the end of the enclosing using block."
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0100.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0101",
              "shortDescription": {
                "text": "String contains an implicit end of line character"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0101.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0102",
              "shortDescription": {
                "text": "Make member readonly"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0102.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0103",
              "shortDescription": {
                "text": "Use SequenceEqual instead of equality operator"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0103.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0104",
              "shortDescription": {
                "text": "Do not create a type with a name from the BCL"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0104.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0105",
              "shortDescription": {
                "text": "Use the lambda parameters instead of using a closure"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0105.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.024",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0106",
              "shortDescription": {
                "text": "Avoid closure by using an overload with the 'factoryArgument' parameter"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0106.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.024",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0107",
              "shortDescription": {
                "text": "Do not use culture-sensitive object.ToString"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0107.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0108",
              "shortDescription": {
                "text": "Remove redundant argument value"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0108.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0109",
              "shortDescription": {
                "text": "Consider adding an overload with a Span<T> or Memory<T>"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0109.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0110",
              "shortDescription": {
                "text": "Use the Regex source generator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0110.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.061",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0111",
              "shortDescription": {
                "text": "Use string.Create instead of FormattableString"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0111.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0112",
              "shortDescription": {
                "text": "Use 'Count > 0' instead of 'Any()'"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0112.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.172",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "MA0113",
              "shortDescription": {
                "text": "Use DateTime.UnixEpoch"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0113.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0114",
              "shortDescription": {
                "text": "Use DateTimeOffset.UnixEpoch"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0114.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0115",
              "shortDescription": {
                "text": "Unknown component parameter"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0115.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0116",
              "shortDescription": {
                "text": "Parameters with [SupplyParameterFromQuery] attributes should also be marked as [Parameter]"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0116.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0117",
              "shortDescription": {
                "text": "Parameters with [EditorRequired] attributes should also be marked as [Parameter]"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0117.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0118",
              "shortDescription": {
                "text": "[JSInvokable] methods must be public"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0118.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0119",
              "shortDescription": {
                "text": "JSRuntime must not be used in OnInitialized or OnInitializedAsync"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0119.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0120",
              "shortDescription": {
                "text": "Use InvokeVoidAsync when the returned value is not used"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0120.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0121",
              "shortDescription": {
                "text": "Do not overwrite parameter value"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0121.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0122",
              "shortDescription": {
                "text": "Parameters with [SupplyParameterFromQuery] attributes are only valid in routable components (@page)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0122.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0123",
              "shortDescription": {
                "text": "Sequence number must be a constant"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0123.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0124",
              "shortDescription": {
                "text": "Log parameter type is not valid"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0124.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0125",
              "shortDescription": {
                "text": "The list of log parameter types contains an invalid type"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0125.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0126",
              "shortDescription": {
                "text": "The list of log parameter types contains a duplicate"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0126.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0127",
              "shortDescription": {
                "text": "Use String.Equals instead of is pattern"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0127.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0128",
              "shortDescription": {
                "text": "Use 'is' operator instead of SequenceEqual"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0128.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0129",
              "shortDescription": {
                "text": "Await task in using statement"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0129.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0130",
              "shortDescription": {
                "text": "GetType() should not be used on System.Type instances"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0130.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0131",
              "shortDescription": {
                "text": "ArgumentNullException.ThrowIfNull should not be used with non-nullable types"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0131.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0132",
              "shortDescription": {
                "text": "Do not convert implicitly to DateTimeOffset"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0132.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0133",
              "shortDescription": {
                "text": "Use DateTimeOffset instead of relying on the implicit conversion"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0133.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0134",
              "shortDescription": {
                "text": "Observe result of async calls"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0134.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0135",
              "shortDescription": {
                "text": "The log parameter has no configured type"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0135.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0136",
              "shortDescription": {
                "text": "Raw String contains an implicit end of line character"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0136.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0137",
              "shortDescription": {
                "text": "Use 'Async' suffix when a method returns an awaitable type"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0137.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0138",
              "shortDescription": {
                "text": "Do not use 'Async' suffix when a method does not return an awaitable type"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0138.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0139",
              "shortDescription": {
                "text": "Log parameter type is not valid"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0139.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0140",
              "shortDescription": {
                "text": "Both if and else branch have identical code"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0140.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0141",
              "shortDescription": {
                "text": "Use pattern matching instead of inequality operators for null check"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0141.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0142",
              "shortDescription": {
                "text": "Use pattern matching instead of equality operators for null check"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0142.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0143",
              "shortDescription": {
                "text": "Primary constructor parameters should be readonly"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0143.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0144",
              "shortDescription": {
                "text": "Use System.OperatingSystem to check the current OS"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0144.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0145",
              "shortDescription": {
                "text": "Signature for [UnsafeAccessorAttribute] method is not valid"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0145.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0146",
              "shortDescription": {
                "text": "Name must be set explicitly on local functions"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0146.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0147",
              "shortDescription": {
                "text": "Avoid async void method for delegate"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0147.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0148",
              "shortDescription": {
                "text": "Use pattern matching instead of equality operators for discrete value"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0148.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0149",
              "shortDescription": {
                "text": "Use pattern matching instead of inequality operators for discrete value"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0149.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0150",
              "shortDescription": {
                "text": "Do not call the default object.ToString explicitly"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0150.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0151",
              "shortDescription": {
                "text": "DebuggerDisplay must contain valid members"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0151.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0152",
              "shortDescription": {
                "text": "Use Unwrap instead of using await twice"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0152.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0153",
              "shortDescription": {
                "text": "Do not log symbols decorated with DataClassificationAttribute directly"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0153.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0154",
              "shortDescription": {
                "text": "Use langword in XML comment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0154.md",
              "properties": {
                "category": "Design",
                "executionTimeInSeconds": "0.070",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0155",
              "shortDescription": {
                "text": "Do not use async void methods"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0155.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0156",
              "shortDescription": {
                "text": "Use 'Async' suffix when a method returns IAsyncEnumerable<T>"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0156.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0157",
              "shortDescription": {
                "text": "Do not use 'Async' suffix when a method does not return IAsyncEnumerable<T>"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0157.md",
              "properties": {
                "category": "Design",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0158",
              "shortDescription": {
                "text": "Use System.Threading.Lock"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0158.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "MA0159",
              "shortDescription": {
                "text": "Use 'Order' instead of 'OrderBy'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0159.md",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.172",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "POLYSP0003",
              "shortDescription": {
                "text": "Unsupported C# language version"
              },
              "fullDescription": {
                "text": "The source generator features from PolySharp require consuming projects to set the C# language version to at least C# 8.0. Make sure to add <LangVersion>8.0</LangVersion> (or above) to your .csproj file."
              },
              "helpUri": "https://github.com/Sergio0694/PolySharp",
              "properties": {
                "category": "Microsoft.CodeAnalysis.CSharp.CSharpParseOptions",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1001",
              "shortDescription": {
                "text": "Add braces (when expression spans over multiple lines)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1001",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1002",
              "shortDescription": {
                "text": "Remove braces"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1002",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1002FadeOut",
              "shortDescription": {
                "text": "Remove braces"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1003",
              "shortDescription": {
                "text": "Add braces to if-else (when expression spans over multiple lines)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1003",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1004",
              "shortDescription": {
                "text": "Remove braces from if-else"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1004",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1004FadeOut",
              "shortDescription": {
                "text": "Remove braces from if-else"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1005",
              "shortDescription": {
                "text": "Simplify nested using statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1005",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1005FadeOut",
              "shortDescription": {
                "text": "Simplify nested using statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1006",
              "shortDescription": {
                "text": "Merge 'else' with nested 'if'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1006",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1006FadeOut",
              "shortDescription": {
                "text": "Merge 'else' with nested 'if'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1007",
              "shortDescription": {
                "text": "Add braces"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1007",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1008",
              "shortDescription": {
                "text": "[deprecated] Use explicit type instead of 'var' (when the type is not obvious)"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1008",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1009",
              "shortDescription": {
                "text": "[deprecated] Use explicit type instead of 'var' (foreach variable)"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1009",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1010",
              "shortDescription": {
                "text": "[deprecated] Use 'var' instead of explicit type (when the type is obvious)"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1010",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1012",
              "shortDescription": {
                "text": "[deprecated] Use explicit type instead of 'var' (when the type is obvious)"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1012",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1013",
              "shortDescription": {
                "text": "Use predefined type"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1013",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1014",
              "shortDescription": {
                "text": "Use explicitly/implicitly typed array"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1014",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1015",
              "shortDescription": {
                "text": "Use nameof operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1015",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1015FadeOut",
              "shortDescription": {
                "text": "Use nameof operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1016",
              "shortDescription": {
                "text": "Use block body or expression body"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1016",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1018",
              "shortDescription": {
                "text": "Add/remove accessibility modifiers"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1018",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1019",
              "shortDescription": {
                "text": "Order modifiers"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1019",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1020",
              "shortDescription": {
                "text": "Simplify Nullable<T> to T?"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1020",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1021",
              "shortDescription": {
                "text": "Convert lambda expression body to expression body"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1021",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1021FadeOut",
              "shortDescription": {
                "text": "Convert lambda expression body to expression body"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1031",
              "shortDescription": {
                "text": "Remove unnecessary braces in switch section"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1031",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.036",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1031FadeOut",
              "shortDescription": {
                "text": "Remove unnecessary braces in switch section"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.036",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1032",
              "shortDescription": {
                "text": "Remove redundant parentheses"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1032",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1032FadeOut",
              "shortDescription": {
                "text": "Remove redundant parentheses"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1033",
              "shortDescription": {
                "text": "Remove redundant boolean literal"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1033",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1034",
              "shortDescription": {
                "text": "Remove redundant 'sealed' modifier"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1034",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1035",
              "shortDescription": {
                "text": "[deprecated] Remove redundant comma in initializer"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1035",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1036",
              "shortDescription": {
                "text": "Remove unnecessary blank line"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1036",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.087",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1037",
              "shortDescription": {
                "text": "Remove trailing white-space"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1037",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1038",
              "shortDescription": {
                "text": "[deprecated] Remove empty statement"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1038",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1039",
              "shortDescription": {
                "text": "Remove argument list from attribute"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1039",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1040",
              "shortDescription": {
                "text": "[deprecated] Remove empty 'else' clause"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1040",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1041",
              "shortDescription": {
                "text": "[deprecated] Remove empty initializer"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1041",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1042",
              "shortDescription": {
                "text": "Remove enum default underlying type"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1042",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1043",
              "shortDescription": {
                "text": "Remove 'partial' modifier from type with a single part"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1043",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1044",
              "shortDescription": {
                "text": "Remove original exception from throw statement"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1044",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1046",
              "shortDescription": {
                "text": "Asynchronous method name should end with 'Async'"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1046",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.032",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1047",
              "shortDescription": {
                "text": "Non-asynchronous method name should not end with 'Async'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1047",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.032",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1047FadeOut",
              "shortDescription": {
                "text": "Non-asynchronous method name should not end with 'Async'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.032",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1048",
              "shortDescription": {
                "text": "Use lambda expression instead of anonymous method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1048",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1048FadeOut",
              "shortDescription": {
                "text": "Use lambda expression instead of anonymous method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1049",
              "shortDescription": {
                "text": "Simplify boolean comparison"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1049",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1049FadeOut",
              "shortDescription": {
                "text": "Simplify boolean comparison"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1050",
              "shortDescription": {
                "text": "Include/omit parentheses when creating new object"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1050",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1051",
              "shortDescription": {
                "text": "Add/remove parentheses from condition in conditional operator"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1051",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1052",
              "shortDescription": {
                "text": "Declare each attribute separately"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1052",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1055",
              "shortDescription": {
                "text": "Unnecessary semicolon at the end of declaration"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1055",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1056",
              "shortDescription": {
                "text": "Avoid usage of using alias directive"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1056",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1058",
              "shortDescription": {
                "text": "Use compound assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1058",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.018",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1058FadeOut",
              "shortDescription": {
                "text": "Use compound assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.018",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1059",
              "shortDescription": {
                "text": "Avoid locking on publicly accessible instance"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1059",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1060",
              "shortDescription": {
                "text": "Declare each type in separate file"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1060",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1061",
              "shortDescription": {
                "text": "Merge 'if' with nested 'if'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1061",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1061FadeOut",
              "shortDescription": {
                "text": "Merge 'if' with nested 'if'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1063",
              "shortDescription": {
                "text": "[deprecated] Avoid usage of do statement to create an infinite loop"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1063",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1064",
              "shortDescription": {
                "text": "[deprecated] Avoid usage of for statement to create an infinite loop"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1064",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1065",
              "shortDescription": {
                "text": "[deprecated] Avoid usage of while statement to create an infinite loop"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1065",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1066",
              "shortDescription": {
                "text": "[deprecated] Remove empty 'finally' clause"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1066",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1066FadeOut",
              "shortDescription": {
                "text": "[deprecated] Remove empty 'finally' clause"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1068",
              "shortDescription": {
                "text": "Simplify logical negation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1068",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1069",
              "shortDescription": {
                "text": "Remove unnecessary case label"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1069",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1070",
              "shortDescription": {
                "text": "Remove redundant default switch section"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1070",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1071",
              "shortDescription": {
                "text": "Remove redundant base constructor call"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1071",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1072",
              "shortDescription": {
                "text": "[deprecated] Remove empty namespace declaration"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1072",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1073",
              "shortDescription": {
                "text": "Convert 'if' to 'return' statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1073",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.125",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1073FadeOut",
              "shortDescription": {
                "text": "Convert 'if' to 'return' statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.125",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1074",
              "shortDescription": {
                "text": "Remove redundant constructor"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1074",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1075",
              "shortDescription": {
                "text": "Avoid empty catch clause that catches System.Exception"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1075",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1077",
              "shortDescription": {
                "text": "Optimize LINQ method call"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1077",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1078",
              "shortDescription": {
                "text": "Use \"\" or 'string.Empty'"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1078",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1079",
              "shortDescription": {
                "text": "Throwing of new NotImplementedException"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1079",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1080",
              "shortDescription": {
                "text": "Use 'Count/Length' property instead of 'Any' method"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1080",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1081",
              "shortDescription": {
                "text": "Split variable declaration"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1081",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1084",
              "shortDescription": {
                "text": "Use coalesce expression instead of conditional expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1084",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1085",
              "shortDescription": {
                "text": "Use auto-implemented property"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1085",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.061",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1085FadeOut",
              "shortDescription": {
                "text": "Use auto-implemented property"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.061",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1089",
              "shortDescription": {
                "text": "Use --/++ operator instead of assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1089",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1089FadeOut",
              "shortDescription": {
                "text": "Use --/++ operator instead of assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1090",
              "shortDescription": {
                "text": "Add/remove 'ConfigureAwait(false)' call"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1090",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1091",
              "shortDescription": {
                "text": "[deprecated] Remove empty region"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1091",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1091FadeOut",
              "shortDescription": {
                "text": "[deprecated] Remove empty region"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1093",
              "shortDescription": {
                "text": "File contains no code"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1093",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1094",
              "shortDescription": {
                "text": "Declare using directive on top level"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1094",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1096",
              "shortDescription": {
                "text": "Use 'HasFlag' method or bitwise operator"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1096",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1097",
              "shortDescription": {
                "text": "Remove redundant 'ToString' call"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1097",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1098",
              "shortDescription": {
                "text": "Constant values should be placed on right side of comparisons"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1098",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1099",
              "shortDescription": {
                "text": "Default label should be the last label in a switch section"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1099",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1100",
              "shortDescription": {
                "text": "[deprecated] Format documentation summary on a single line"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1100",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1101",
              "shortDescription": {
                "text": "[deprecated] Format documentation summary on multiple lines"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1101",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1102",
              "shortDescription": {
                "text": "Make class static"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1102",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1103",
              "shortDescription": {
                "text": "Convert 'if' to assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1103",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.125",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1104",
              "shortDescription": {
                "text": "Simplify conditional expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1104",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1105",
              "shortDescription": {
                "text": "Unnecessary interpolation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1105",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1106",
              "shortDescription": {
                "text": "[deprecated] Remove empty destructor"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1106",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1107",
              "shortDescription": {
                "text": "Remove redundant 'ToCharArray' call"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1107",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1108",
              "shortDescription": {
                "text": "Add 'static' modifier to all partial class declarations"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1108",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1110",
              "shortDescription": {
                "text": "Declare type inside namespace"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1110",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1111",
              "shortDescription": {
                "text": "Add braces to switch section with multiple statements"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1111",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1112",
              "shortDescription": {
                "text": "Combine 'Enumerable.Where' method chain"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1112",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1112FadeOut",
              "shortDescription": {
                "text": "Combine 'Enumerable.Where' method chain"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1113",
              "shortDescription": {
                "text": "Use 'string.IsNullOrEmpty' method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1113",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1114",
              "shortDescription": {
                "text": "Remove redundant delegate creation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1114",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1114FadeOut",
              "shortDescription": {
                "text": "Remove redundant delegate creation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1118",
              "shortDescription": {
                "text": "Mark local variable as const"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1118",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1123",
              "shortDescription": {
                "text": "Add parentheses when necessary"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1123",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1124",
              "shortDescription": {
                "text": "Inline local variable"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1124",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.052",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1124FadeOut",
              "shortDescription": {
                "text": "Inline local variable"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.052",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1126",
              "shortDescription": {
                "text": "Add braces to if-else"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1126",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1128",
              "shortDescription": {
                "text": "Use coalesce expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1128",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1129",
              "shortDescription": {
                "text": "Remove redundant field initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1129",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1130",
              "shortDescription": {
                "text": "Bitwise operation on enum without Flags attribute"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1130",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1132",
              "shortDescription": {
                "text": "Remove redundant overriding member"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1132",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.034",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1133",
              "shortDescription": {
                "text": "Remove redundant Dispose/Close call"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1133",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1134",
              "shortDescription": {
                "text": "Remove redundant statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1134",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1135",
              "shortDescription": {
                "text": "Declare enum member with zero value (when enum has FlagsAttribute)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1135",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.056",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1136",
              "shortDescription": {
                "text": "Merge switch sections with equivalent content"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1136",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1138",
              "shortDescription": {
                "text": "Add summary to documentation comment"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1138",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.330",
                "executionTimeInPercentage": "2"
              }
            },
            {
              "id": "RCS1139",
              "shortDescription": {
                "text": "Add summary element to documentation comment"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1139",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.330",
                "executionTimeInPercentage": "2"
              }
            },
            {
              "id": "RCS1140",
              "shortDescription": {
                "text": "Add exception to documentation comment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1140",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1141",
              "shortDescription": {
                "text": "Add 'param' element to documentation comment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1141",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.330",
                "executionTimeInPercentage": "2"
              }
            },
            {
              "id": "RCS1142",
              "shortDescription": {
                "text": "Add 'typeparam' element to documentation comment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1142",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.330",
                "executionTimeInPercentage": "2"
              }
            },
            {
              "id": "RCS1143",
              "shortDescription": {
                "text": "Simplify coalesce expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1143",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1145",
              "shortDescription": {
                "text": "Remove redundant 'as' operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1145",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1146",
              "shortDescription": {
                "text": "Use conditional access"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1146",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1151",
              "shortDescription": {
                "text": "Remove redundant cast"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1151",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1154",
              "shortDescription": {
                "text": "Sort enum members"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1154",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1155",
              "shortDescription": {
                "text": "Use StringComparison when comparing strings"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1155",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1156",
              "shortDescription": {
                "text": "Use string.Length instead of comparison with empty string"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1156",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1157",
              "shortDescription": {
                "text": "Composite enum value contains undefined flag"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1157",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.056",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1158",
              "shortDescription": {
                "text": "Static member in generic type should use a type parameter"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1158",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.027",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1159",
              "shortDescription": {
                "text": "Use EventHandler<T>"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1159",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1160",
              "shortDescription": {
                "text": "Abstract type should not have public constructors"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1160",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.065",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1161",
              "shortDescription": {
                "text": "Enum should declare explicit values"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1161",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1162",
              "shortDescription": {
                "text": "Avoid chain of assignments"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1162",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1163",
              "shortDescription": {
                "text": "Unused parameter"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1163",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.083",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1164",
              "shortDescription": {
                "text": "Unused type parameter"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1164",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.083",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1165",
              "shortDescription": {
                "text": "Unconstrained type parameter checked for null"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1165",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1166",
              "shortDescription": {
                "text": "Value type object is never equal to null"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1166",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1168",
              "shortDescription": {
                "text": "Parameter name differs from base name"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1168",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1169",
              "shortDescription": {
                "text": "Make field read-only"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1169",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.021",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1170",
              "shortDescription": {
                "text": "Use read-only auto-implemented property"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1170",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.021",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1171",
              "shortDescription": {
                "text": "Simplify lazy initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1171",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.031",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1172",
              "shortDescription": {
                "text": "Use 'is' operator instead of 'as' operator"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1172",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1173",
              "shortDescription": {
                "text": "Use coalesce expression instead of 'if'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1173",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.125",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1174",
              "shortDescription": {
                "text": "Remove redundant async/await"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1174",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1174FadeOut",
              "shortDescription": {
                "text": "Remove redundant async/await"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1175",
              "shortDescription": {
                "text": "Unused 'this' parameter"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1175",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.083",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1176",
              "shortDescription": {
                "text": "[deprecated] Use 'var' instead of explicit type (when the type is not obvious)"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1176",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1177",
              "shortDescription": {
                "text": "[deprecated] Use 'var' instead of explicit type (in foreach)"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1177",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1179",
              "shortDescription": {
                "text": "Unnecessary assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1179",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1180",
              "shortDescription": {
                "text": "Inline lazy initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1180",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.018",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1181",
              "shortDescription": {
                "text": "Convert comment to documentation comment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1181",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1182",
              "shortDescription": {
                "text": "Remove redundant base interface"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1182",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1186",
              "shortDescription": {
                "text": "Use Regex instance instead of static method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1186",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1187",
              "shortDescription": {
                "text": "Use constant instead of field"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1187",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1188",
              "shortDescription": {
                "text": "Remove redundant auto-property initialization"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1188",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1189",
              "shortDescription": {
                "text": "Add or remove region name"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1189",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1190",
              "shortDescription": {
                "text": "Join string expressions"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1190",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1191",
              "shortDescription": {
                "text": "Declare enum value as combination of names"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1191",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.056",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1192",
              "shortDescription": {
                "text": "Unnecessary usage of verbatim string literal"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1192",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1193",
              "shortDescription": {
                "text": "Overriding member should not change 'params' modifier"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1193",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1194",
              "shortDescription": {
                "text": "Implement exception constructors"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1194",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1195",
              "shortDescription": {
                "text": "Use ^ operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1195",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1196",
              "shortDescription": {
                "text": "Call extension method as instance method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1196",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1197",
              "shortDescription": {
                "text": "Optimize StringBuilder.Append/AppendLine call"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1197",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1198",
              "shortDescription": {
                "text": "Avoid unnecessary boxing of value type"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1198",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1199",
              "shortDescription": {
                "text": "Unnecessary null check"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1199",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1200",
              "shortDescription": {
                "text": "Call 'Enumerable.ThenBy' instead of 'Enumerable.OrderBy'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1200",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1201",
              "shortDescription": {
                "text": "Use method chaining"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1201",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1202",
              "shortDescription": {
                "text": "Avoid NullReferenceException"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1202",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1203",
              "shortDescription": {
                "text": "Use AttributeUsageAttribute"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1203",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1204",
              "shortDescription": {
                "text": "Use EventArgs.Empty"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1204",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1205",
              "shortDescription": {
                "text": "Order named arguments according to the order of parameters"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1205",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1206",
              "shortDescription": {
                "text": "Use conditional access instead of conditional expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1206",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1207",
              "shortDescription": {
                "text": "Use anonymous function or method group"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1207",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1208",
              "shortDescription": {
                "text": "Reduce 'if' nesting"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1208",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1209",
              "shortDescription": {
                "text": "Order type parameter constraints"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1209",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1210",
              "shortDescription": {
                "text": "Return completed task instead of returning null"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1210",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.040",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1211",
              "shortDescription": {
                "text": "Remove unnecessary 'else'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1211",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1212",
              "shortDescription": {
                "text": "Remove redundant assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1212",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.042",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1212FadeOut",
              "shortDescription": {
                "text": "Remove redundant assignment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.042",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1213",
              "shortDescription": {
                "text": "Remove unused member declaration"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1213",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.054",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1214",
              "shortDescription": {
                "text": "Unnecessary interpolated string"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1214",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1214FadeOut",
              "shortDescription": {
                "text": "Unnecessary interpolated string"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1215",
              "shortDescription": {
                "text": "Expression is always equal to true/false"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1215",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.018",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1216",
              "shortDescription": {
                "text": "Unnecessary unsafe context"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1216",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1217",
              "shortDescription": {
                "text": "Convert interpolated string to concatenation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1217",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1217FadeOut",
              "shortDescription": {
                "text": "Convert interpolated string to concatenation"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "RCS1218",
              "shortDescription": {
                "text": "Simplify code branching"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1218",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1220",
              "shortDescription": {
                "text": "Use pattern matching instead of combination of 'is' operator and cast operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1220",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1221",
              "shortDescription": {
                "text": "Use pattern matching instead of combination of 'as' operator and null check"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1221",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1222",
              "shortDescription": {
                "text": "Merge preprocessor directives"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1222",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1223",
              "shortDescription": {
                "text": "Mark publicly visible type with DebuggerDisplay attribute"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1223",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1224",
              "shortDescription": {
                "text": "Make method an extension method"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1224",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1225",
              "shortDescription": {
                "text": "Make class sealed"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1225",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1226",
              "shortDescription": {
                "text": "Add paragraph to documentation comment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1226",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.022",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1227",
              "shortDescription": {
                "text": "Validate arguments correctly"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1227",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.028",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1228",
              "shortDescription": {
                "text": "Unused element in a documentation comment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1228",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.330",
                "executionTimeInPercentage": "2",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1229",
              "shortDescription": {
                "text": "Use async/await when necessary"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1229",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1230",
              "shortDescription": {
                "text": "Unnecessary explicit use of enumerator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1230",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1231",
              "shortDescription": {
                "text": "Make parameter ref read-only"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1231",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.021",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1232",
              "shortDescription": {
                "text": "Order elements in documentation comment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1232",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.330",
                "executionTimeInPercentage": "2"
              }
            },
            {
              "id": "RCS1233",
              "shortDescription": {
                "text": "Use short-circuiting operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1233",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1234",
              "shortDescription": {
                "text": "Duplicate enum value"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1234",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.056",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1235",
              "shortDescription": {
                "text": "Optimize method call"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1235",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1236",
              "shortDescription": {
                "text": "Use exception filter"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1236",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1237",
              "shortDescription": {
                "text": "[deprecated] Use bit shift operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1237",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.056",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1238",
              "shortDescription": {
                "text": "Avoid nested ?: operators"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1238",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1239",
              "shortDescription": {
                "text": "Use 'for' statement instead of 'while' statement"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1239",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1240",
              "shortDescription": {
                "text": "Operator is unnecessary"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1240",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.018",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1241",
              "shortDescription": {
                "text": "Implement non-generic counterpart"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1241",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1242",
              "shortDescription": {
                "text": "Do not pass non-read-only struct by read-only reference"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1242",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.021",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1243",
              "shortDescription": {
                "text": "Duplicate word in a comment"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1243",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1244",
              "shortDescription": {
                "text": "Simplify 'default' expression"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1244",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1246",
              "shortDescription": {
                "text": "Use element access"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1246",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1247",
              "shortDescription": {
                "text": "Fix documentation comment tag"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1247",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.330",
                "executionTimeInPercentage": "2"
              }
            },
            {
              "id": "RCS1248",
              "shortDescription": {
                "text": "Normalize null check"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1248",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1249",
              "shortDescription": {
                "text": "Unnecessary null-forgiving operator"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1249",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1250",
              "shortDescription": {
                "text": "Use implicit/explicit object creation"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1250",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1251",
              "shortDescription": {
                "text": "Remove unnecessary braces from record declaration"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1251",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1252",
              "shortDescription": {
                "text": "Normalize usage of infinite loop"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1252",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1253",
              "shortDescription": {
                "text": "Format documentation comment summary"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1253",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1254",
              "shortDescription": {
                "text": "Normalize format of enum flag value"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1254",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1255",
              "shortDescription": {
                "text": "Simplify argument null check"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1255",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1256",
              "shortDescription": {
                "text": "Invalid argument null check"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1256",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1257",
              "shortDescription": {
                "text": "Use enum field explicitly"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1257",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1258",
              "shortDescription": {
                "text": "Unnecessary enum flag"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1258",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1259",
              "shortDescription": {
                "text": "Remove empty syntax"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1259",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1260",
              "shortDescription": {
                "text": "Add/remove trailing comma"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1260",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1261",
              "shortDescription": {
                "text": "Resource can be disposed asynchronously"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1261",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1262",
              "shortDescription": {
                "text": "Unnecessary raw string literal"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1262",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "RCS1263",
              "shortDescription": {
                "text": "Invalid reference in a documentation comment"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1263",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.330",
                "executionTimeInPercentage": "2"
              }
            },
            {
              "id": "RCS1264",
              "shortDescription": {
                "text": "Use 'var' or explicit type"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1264",
              "properties": {
                "category": "Roslynator",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1265",
              "shortDescription": {
                "text": "Remove redundant catch block"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1265",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1266",
              "shortDescription": {
                "text": "Use raw string literal"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1266",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RCS1267",
              "shortDescription": {
                "text": "Use string interpolation instead of 'string.Concat'"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1267",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "0.184",
                "executionTimeInPercentage": "1"
              }
            },
            {
              "id": "RCS1268",
              "shortDescription": {
                "text": "Simplify numeric comparison"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/RCS1268",
              "properties": {
                "category": "Roslynator",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RemoveUnnecessaryImportsFixable",
              "defaultConfiguration": {
                "level": "note"
              },
              "properties": {
                "category": "Style",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "0.136",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry",
                  "EnforceOnBuild_Never",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "ROS0002",
              "shortDescription": {
                "text": "Analyzer option is obsolete"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/",
              "properties": {
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "ROS0003",
              "shortDescription": {
                "text": "Analyzer requires config option to be specified"
              },
              "defaultConfiguration": {
                "level": "note",
                "enabled": false
              },
              "helpUri": "https://josefpihrt.github.io/docs/roslynator/analyzers/",
              "properties": {
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RS1001",
              "shortDescription": {
                "text": "Missing diagnostic analyzer attribute"
              },
              "fullDescription": {
                "text": "Non-abstract sub-types of DiagnosticAnalyzer should be marked with DiagnosticAnalyzerAttribute(s). The argument to this attribute(s), if any, determine the supported languages for the analyzer. Analyzer types without this attribute will be ignored by the analysis engine."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1002",
              "shortDescription": {
                "text": "Missing kind argument when registering an analyzer action"
              },
              "fullDescription": {
                "text": "You must specify at least one syntax, symbol or operation kind when registering a syntax, symbol, or operation analyzer action respectively. Otherwise, the registered action will never be invoked during analysis."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1003",
              "shortDescription": {
                "text": "Unsupported SymbolKind argument when registering a symbol analyzer action"
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1004",
              "shortDescription": {
                "text": "Recommend adding language support to diagnostic analyzer"
              },
              "fullDescription": {
                "text": "Diagnostic analyzer is marked as supporting only one language, but the analyzer assembly doesn't seem to refer to any language specific CodeAnalysis assemblies, and so is likely to work for more than one language. Consider adding an additional language argument to DiagnosticAnalyzerAttribute."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1005",
              "shortDescription": {
                "text": "ReportDiagnostic invoked with an unsupported DiagnosticDescriptor"
              },
              "fullDescription": {
                "text": "ReportDiagnostic should only be invoked with supported DiagnosticDescriptors that are returned from DiagnosticAnalyzer.SupportedDiagnostics property. Otherwise, the reported diagnostic will be filtered out by the analysis engine."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1006",
              "shortDescription": {
                "text": "Invalid type argument for DiagnosticAnalyzer's Register method"
              },
              "fullDescription": {
                "text": "DiagnosticAnalyzer's language-specific Register methods, such as RegisterSyntaxNodeAction, RegisterCodeBlockStartAction and RegisterCodeBlockEndAction, expect a language-specific 'SyntaxKind' type argument for it's 'TLanguageKindEnumName' type parameter. Otherwise, the registered analyzer action can never be invoked during analysis."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1007",
              "shortDescription": {
                "text": "Provide localizable arguments to diagnostic descriptor constructor"
              },
              "fullDescription": {
                "text": "If your diagnostic analyzer and it's reported diagnostics need to be localizable, then the supported DiagnosticDescriptors used for constructing the diagnostics must also be localizable. If so, then localizable argument(s) must be provided for parameter 'title' (and optionally 'description') to the diagnostic descriptor constructor to ensure that the descriptor is localizable."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisLocalization",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1008",
              "shortDescription": {
                "text": "Avoid storing per-compilation data into the fields of a diagnostic analyzer"
              },
              "fullDescription": {
                "text": "Instance of a diagnostic analyzer might outlive the lifetime of compilation. Hence, storing per-compilation data, such as symbols, into the fields of a diagnostic analyzer might cause stale compilations to stay alive and cause memory leaks.  Instead, you should store this data on a separate type instantiated in a compilation start action, registered using 'AnalysisContext.RegisterCompilationStartAction' API. An instance of this type will be created per-compilation and it won't outlive compilation's lifetime, hence avoiding memory leaks."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisPerformance",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1009",
              "shortDescription": {
                "text": "Only internal implementations of this interface are allowed"
              },
              "fullDescription": {
                "text": "The author of this interface did not intend to have third party implementations of this interface and reserves the right to change it. Implementing this interface could therefore result in a source or binary compatibility issue with a future version of this interface."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCompatibility",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "RS1010",
              "shortDescription": {
                "text": "Create code actions should have a unique EquivalenceKey for FixAll occurrences support"
              },
              "fullDescription": {
                "text": "A CodeFixProvider that intends to support fix all occurrences must classify the registered code actions into equivalence classes by assigning it an explicit, non-null equivalence key which is unique for each kind of code action created by this fixer. This enables the FixAllProvider to fix all diagnostics in the required scope by applying code actions from this fixer that are in the equivalence class of the trigger code action."
              },
              "properties": {
                "category": "Correctness",
                "executionTimeInSeconds": "0.035",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1011",
              "shortDescription": {
                "text": "Use code actions that have a unique EquivalenceKey for FixAll occurrences support"
              },
              "fullDescription": {
                "text": "A CodeFixProvider that intends to support fix all occurrences must classify the registered code actions into equivalence classes by assigning it an explicit, non-null equivalence key which is unique for each kind of code action created by this fixer. This enables the FixAllProvider to fix all diagnostics in the required scope by applying code actions from this fixer that are in the equivalence class of the trigger code action."
              },
              "properties": {
                "category": "Correctness",
                "executionTimeInSeconds": "0.035",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1012",
              "shortDescription": {
                "text": "Start action has no registered actions"
              },
              "fullDescription": {
                "text": "An analyzer start action enables performing stateful analysis over a given code unit, such as a code block, compilation, etc. Careful design is necessary to achieve efficient analyzer execution without memory leaks. Use the following guidelines for writing such analyzers:\u000d\u000a1. Define a new scope for the registered start action, possibly with a private nested type for analyzing each code unit.\u000d\u000a2. If required, define and initialize state in the start action.\u000d\u000a3. Register at least one non-end action that refers to this state in the start action. If no such action is necessary, consider replacing the start action with a non-start action. For example, a CodeBlockStartAction with no registered actions or only a registered CodeBlockEndAction should be replaced with a CodeBlockAction.\u000d\u000a4. If required, register an end action to report diagnostics based on the final state."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisPerformance",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1013",
              "shortDescription": {
                "text": "Start action has no registered non-end actions"
              },
              "fullDescription": {
                "text": "An analyzer start action enables performing stateful analysis over a given code unit, such as a code block, compilation, etc. Careful design is necessary to achieve efficient analyzer execution without memory leaks. Use the following guidelines for writing such analyzers:\u000d\u000a1. Define a new scope for the registered start action, possibly with a private nested type for analyzing each code unit.\u000d\u000a2. If required, define and initialize state in the start action.\u000d\u000a3. Register at least one non-end action that refers to this state in the start action. If no such action is necessary, consider replacing the start action with a non-start action. For example, a CodeBlockStartAction with no registered actions or only a registered CodeBlockEndAction should be replaced with a CodeBlockAction.\u000d\u000a4. If required, register an end action to report diagnostics based on the final state."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisPerformance",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1014",
              "shortDescription": {
                "text": "Do not ignore values returned by methods on immutable objects"
              },
              "fullDescription": {
                "text": "Many objects exposed by Roslyn are immutable. The return value from a method invocation on these objects should not be ignored."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1015",
              "shortDescription": {
                "text": "Provide non-null 'helpLinkUri' value to diagnostic descriptor constructor"
              },
              "fullDescription": {
                "text": "The 'helpLinkUri' value is used to show information when this diagnostic in the error list. Every analyzer should have a helpLinkUri specified which points to a help page that does not change over time."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDocumentation",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1016",
              "shortDescription": {
                "text": "Code fix providers should provide FixAll support"
              },
              "fullDescription": {
                "text": "A CodeFixProvider should provide FixAll support to enable users to fix multiple instances of the underlying diagnostic with a single code fix. See documentation at https://github.com/dotnet/roslyn/blob/main/docs/analyzers/FixAllProvider.md for further details."
              },
              "properties": {
                "category": "Correctness",
                "executionTimeInSeconds": "0.035",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1017",
              "shortDescription": {
                "text": "DiagnosticId for analyzers must be a non-null constant"
              },
              "fullDescription": {
                "text": "DiagnosticId for analyzers must be a non-null constant."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1018",
              "shortDescription": {
                "text": "DiagnosticId for analyzers must be in specified format"
              },
              "fullDescription": {
                "text": "DiagnosticId for analyzers must be in specified format."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1019",
              "shortDescription": {
                "text": "DiagnosticId must be unique across analyzers"
              },
              "fullDescription": {
                "text": "DiagnosticId must be unique across analyzers."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1020",
              "shortDescription": {
                "text": "Category for analyzers must be from the specified values"
              },
              "fullDescription": {
                "text": "Category for analyzers must be from the specified values."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1021",
              "shortDescription": {
                "text": "Invalid entry in analyzer category and diagnostic ID range specification file"
              },
              "fullDescription": {
                "text": "Invalid entry in analyzer category and diagnostic ID range specification file."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1022",
              "shortDescription": {
                "text": "Do not use types from Workspaces assembly in an analyzer"
              },
              "fullDescription": {
                "text": "Diagnostic analyzer types should not use types from Workspaces assemblies. Workspaces assemblies are only available when the analyzer executes in Visual Studio IDE live analysis, but are not available during command line build. Referencing types from Workspaces assemblies will lead to runtime exception during analyzer execution in command line build."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1023",
              "shortDescription": {
                "text": "Upgrade MSBuildWorkspace"
              },
              "fullDescription": {
                "text": "MSBuildWorkspace has moved to the Microsoft.CodeAnalysis.Workspaces.MSBuild NuGet package and there are breaking API changes."
              },
              "helpUri": "https://go.microsoft.com/fwlink/?linkid=874285",
              "properties": {
                "category": "Library",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1024",
              "shortDescription": {
                "text": "Symbols should be compared for equality"
              },
              "fullDescription": {
                "text": "Symbols should be compared for equality, not identity. Use an overload accepting an 'IEqualityComparer' and pass 'SymbolEqualityComparer'."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1025",
              "shortDescription": {
                "text": "Configure generated code analysis"
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1026",
              "shortDescription": {
                "text": "Enable concurrent execution"
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1027",
              "shortDescription": {
                "text": "Types marked with DiagnosticAnalyzerAttribute(s) should inherit from DiagnosticAnalyzer"
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1028",
              "shortDescription": {
                "text": "Provide non-null 'customTags' value to diagnostic descriptor constructor"
              },
              "fullDescription": {
                "text": "The 'customTags' value is used as a way to enable specific actions and filters on diagnostic descriptors based on the specific values of the tags. Every Roslyn analyzer should have at least one tag from the 'WellKnownDiagnosticTags' class."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDocumentation",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1029",
              "shortDescription": {
                "text": "Do not use reserved diagnostic IDs"
              },
              "fullDescription": {
                "text": "DiagnosticId for analyzers should not use reserved IDs."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1030",
              "shortDescription": {
                "text": "Do not invoke Compilation.GetSemanticModel() method within a diagnostic analyzer"
              },
              "fullDescription": {
                "text": "'GetSemanticModel' is an expensive method to invoke within a diagnostic analyzer because it creates a completely new semantic model, which does not share compilation data with the compiler or other analyzers. This incurs an additional performance cost during semantic analysis. Instead, consider registering a different analyzer action which allows used of a shared 'SemanticModel', such as 'RegisterOperationAction', 'RegisterSyntaxNodeAction', or 'RegisterSemanticModelAction'."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1031",
              "shortDescription": {
                "text": "Define diagnostic title correctly"
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1032",
              "shortDescription": {
                "text": "Define diagnostic message correctly"
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1033",
              "shortDescription": {
                "text": "Define diagnostic description correctly"
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1034",
              "shortDescription": {
                "text": "Prefer 'IsKind' for checking syntax kinds"
              },
              "fullDescription": {
                "text": "Prefer 'syntax.IsKind(kind)' to 'syntax.Kind() == kind' when checking syntax kinds. Code using 'IsKind' is slightly more efficient at runtime, so consistent use of this form where applicable helps improve performance in complex analysis scenarios."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisPerformance",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1035",
              "shortDescription": {
                "text": "Do not use APIs banned for analyzers"
              },
              "fullDescription": {
                "text": "The symbol has been marked as banned for use in analyzers, and an alternate should be used instead."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "0.032",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1036",
              "shortDescription": {
                "text": "Specify analyzer banned API enforcement setting"
              },
              "fullDescription": {
                "text": "A project containing analyzers or source generators should specify the property '<EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>'."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisCorrectness",
                "executionTimeInSeconds": "0.032",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS1037",
              "shortDescription": {
                "text": "Add \"CompilationEnd\" custom tag to compilation end diagnostic descriptor"
              },
              "fullDescription": {
                "text": "'DiagnosticDescriptor' assigned to field is used to report a compilation end diagnostic, but the 'DiagnosticDescriptor' constructor used to initialize it does not pass in the required custom tag \"CompilationEnd\". See documentation for 'WellKnownDiagnosticTags.CompilationEnd' for details."
              },
              "properties": {
                "category": "MicrosoftCodeAnalysisDesign",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS2000",
              "shortDescription": {
                "text": "Add analyzer diagnostic IDs to analyzer release"
              },
              "fullDescription": {
                "text": "All supported analyzer diagnostic IDs should be part of an analyzer release."
              },
              "helpUri": "https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md",
              "properties": {
                "category": "MicrosoftCodeAnalysisReleaseTracking",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS2001",
              "shortDescription": {
                "text": "Ensure up-to-date entry for analyzer diagnostic IDs are added to analyzer release"
              },
              "fullDescription": {
                "text": "Ensure up-to-date entry for analyzer diagnostic IDs are added to analyzer release."
              },
              "helpUri": "https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md",
              "properties": {
                "category": "MicrosoftCodeAnalysisReleaseTracking",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS2002",
              "shortDescription": {
                "text": "Do not add removed analyzer diagnostic IDs to unshipped analyzer release"
              },
              "fullDescription": {
                "text": "Entries for analyzer diagnostic IDs that are no longer reported and never shipped can be removed from unshipped analyzer release."
              },
              "helpUri": "https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md",
              "properties": {
                "category": "MicrosoftCodeAnalysisReleaseTracking",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS2003",
              "shortDescription": {
                "text": "Shipped diagnostic IDs that are no longer reported should have an entry in the 'Removed Rules' table in unshipped file"
              },
              "fullDescription": {
                "text": "Shipped diagnostic IDs that are no longer reported should have an entry in the 'Removed Rules' table in unshipped file."
              },
              "helpUri": "https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md",
              "properties": {
                "category": "MicrosoftCodeAnalysisReleaseTracking",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS2004",
              "shortDescription": {
                "text": "Diagnostic IDs marked as removed in analyzer release file should not be reported by analyzers"
              },
              "fullDescription": {
                "text": "Diagnostic IDs marked as removed in analyzer release file should not be reported by analyzers."
              },
              "helpUri": "https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md",
              "properties": {
                "category": "MicrosoftCodeAnalysisReleaseTracking",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS2005",
              "shortDescription": {
                "text": "Remove duplicate entries for diagnostic ID in the same analyzer release"
              },
              "fullDescription": {
                "text": "Remove duplicate entries for diagnostic ID in the same analyzer release."
              },
              "helpUri": "https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md",
              "properties": {
                "category": "MicrosoftCodeAnalysisReleaseTracking",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS2006",
              "shortDescription": {
                "text": "Remove duplicate entries for diagnostic ID between analyzer releases"
              },
              "fullDescription": {
                "text": "Remove duplicate entries for diagnostic ID between analyzer releases."
              },
              "helpUri": "https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md",
              "properties": {
                "category": "MicrosoftCodeAnalysisReleaseTracking",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS2007",
              "shortDescription": {
                "text": "Invalid entry in analyzer release file"
              },
              "fullDescription": {
                "text": "Invalid entry in analyzer release file."
              },
              "helpUri": "https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md",
              "properties": {
                "category": "MicrosoftCodeAnalysisReleaseTracking",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "RS2008",
              "shortDescription": {
                "text": "Enable analyzer release tracking"
              },
              "fullDescription": {
                "text": "Enabling release tracking for analyzer packages helps in tracking and documenting the analyzer diagnostics that ship and/or change with each analyzer release. See details at https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md."
              },
              "helpUri": "https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md",
              "properties": {
                "category": "MicrosoftCodeAnalysisReleaseTracking",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Telemetry"
                ]
              }
            },
            {
              "id": "S100",
              "shortDescription": {
                "text": "Methods and properties should be named in PascalCase"
              },
              "fullDescription": {
                "text": "Shared naming conventions allow teams to collaborate efficiently."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-100",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.068",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1006",
              "shortDescription": {
                "text": "Method overrides should not change parameter defaults"
              },
              "fullDescription": {
                "text": "Default arguments are determined by the static type of the object."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1006",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S101",
              "shortDescription": {
                "text": "Types should be named in PascalCase"
              },
              "fullDescription": {
                "text": "Shared naming conventions allow teams to collaborate efficiently."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-101",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.068",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S103",
              "shortDescription": {
                "text": "Lines should not be too long"
              },
              "fullDescription": {
                "text": "Scrolling horizontally to see a full line of code lowers the code readability."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-103",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S104",
              "shortDescription": {
                "text": "Files should not have too many lines of code"
              },
              "fullDescription": {
                "text": "When a source file grows too much, it can accumulate numerous responsibilities and become challenging to understand and maintain."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-104",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1048",
              "shortDescription": {
                "text": "Finalizers should not throw exceptions"
              },
              "fullDescription": {
                "text": "The finalizers are used to perform any necessary final clean-up when the garbage collector is collecting a class instance. The programmer has no control over when the finalizer is called; the garbage collector decides when to call it."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1048",
              "properties": {
                "category": "Blocker Bug",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S105",
              "shortDescription": {
                "text": "Tabulation characters should not be used"
              },
              "fullDescription": {
                "text": "The tab width can differ from one development environment to another. Using tabs may require other developers to configure their environment (text editor, preferences, etc.) to read source code."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-105",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S106",
              "shortDescription": {
                "text": "Standard outputs should not be used directly to log anything"
              },
              "fullDescription": {
                "text": "In software development, logs serve as a record of events within an application, providing crucial insights for debugging. When logging, it is essential to ensure that the logs are:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-106",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1066",
              "shortDescription": {
                "text": "Mergeable \"if\" statements should be combined"
              },
              "fullDescription": {
                "text": "Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as possible, by avoiding unnecessary nesting, is considered a good practice."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1066",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1067",
              "shortDescription": {
                "text": "Expressions should not be too complex"
              },
              "fullDescription": {
                "text": "The complexity of an expression is defined by the number of &&, || and condition ? ifTrue : ifFalse operators it contains."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1067",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S107",
              "shortDescription": {
                "text": "Methods should not have too many parameters"
              },
              "fullDescription": {
                "text": "Methods with a long parameter list are difficult to use because maintainers must figure out the role of each parameter and keep track of their position."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-107",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1075",
              "shortDescription": {
                "text": "URIs should not be hardcoded"
              },
              "fullDescription": {
                "text": "Hard-coding a URI makes it difficult to test a program for a variety of reasons:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1075",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.022",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S108",
              "shortDescription": {
                "text": "Nested blocks of code should not be left empty"
              },
              "fullDescription": {
                "text": "An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is incomplete."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-108",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S109",
              "shortDescription": {
                "text": "Magic numbers should not be used"
              },
              "fullDescription": {
                "text": "A magic number is a hard-coded numerical value that may lack context or meaning. They should not be used because they can make the code less readable and maintainable."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-109",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S110",
              "shortDescription": {
                "text": "Inheritance tree of classes should not be too deep"
              },
              "fullDescription": {
                "text": "Inheritance is one of the most valuable concepts in object-oriented programming. It’s a way to categorize and reuse code by creating collections of attributes and behaviors called classes, which can be based on previously created classes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-110",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1104",
              "shortDescription": {
                "text": "Fields should not have public accessibility"
              },
              "fullDescription": {
                "text": "Public fields in public classes do not respect the encapsulation principle and have three main disadvantages:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1104",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1109",
              "shortDescription": {
                "text": "A close curly brace should be located at the beginning of a line"
              },
              "fullDescription": {
                "text": "Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the beginning of a line."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1109",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1110",
              "shortDescription": {
                "text": "Redundant pairs of parentheses should be removed"
              },
              "fullDescription": {
                "text": "Parentheses can disambiguate the order of operations in complex expressions and make the code easier to understand."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1110",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1116",
              "shortDescription": {
                "text": "Empty statements should be removed"
              },
              "fullDescription": {
                "text": "Empty statements represented by a semicolon ; are statements that do not perform any operation. They are often the result of a typo or a misunderstanding of the language syntax. It is a good practice to remove empty statements since they don’t add value and lead to confusion and errors."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1116",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1117",
              "shortDescription": {
                "text": "Local variables should not shadow class fields or properties"
              },
              "fullDescription": {
                "text": "Shadowing occurs when a local variable has the same name as a variable, field, or property in an outer scope."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1117",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.041",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1118",
              "shortDescription": {
                "text": "Utility classes should not have public constructors"
              },
              "fullDescription": {
                "text": "Whenever there are portions of code that are duplicated and do not depend on the state of their container class, they can be centralized inside a \"utility class\". A utility class is a class that only has static members, hence it should not be instantiated."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1118",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S112",
              "shortDescription": {
                "text": "General or reserved exceptions should never be thrown"
              },
              "fullDescription": {
                "text": "This rule raises an issue when a general or reserved exception is thrown."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-112",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1121",
              "shortDescription": {
                "text": "Assignments should not be made from within sub-expressions"
              },
              "fullDescription": {
                "text": "A common code smell that can hinder the clarity of source code is making assignments within sub-expressions. This practice involves assigning a value to a variable inside a larger expression, such as within a loop or a conditional statement."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1121",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1123",
              "shortDescription": {
                "text": "\"Obsolete\" attributes should include explanations"
              },
              "fullDescription": {
                "text": "The Obsolete attribute can be applied with or without a message argument. Marking something Obsolete without including advice on why it’s obsolete or what to use instead will lead maintainers to waste time trying to figure those things out."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1123",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1125",
              "shortDescription": {
                "text": "Boolean literals should not be redundant"
              },
              "fullDescription": {
                "text": "A boolean literal can be represented in two different ways: true or false. They can be combined with logical operators (!, &&, ||, ==, !=) to produce logical expressions that represent truth values. However, comparing a boolean literal to a variable or expression that evaluates to a boolean value is unnecessary and can make the code harder to read and understand. The more complex a boolean expression is, the harder it will be for developers to understand its meaning and expected behavior, and it will favour the introduction of new bugs."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1125",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.050",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1128",
              "shortDescription": {
                "text": "Unnecessary \"using\" should be removed"
              },
              "fullDescription": {
                "text": "Unnecessary using directives refer to importing namespaces, types or creating aliases that are not used or referenced anywhere in the code."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1128",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S113",
              "shortDescription": {
                "text": "Files should end with a newline"
              },
              "fullDescription": {
                "text": "Some tools work better when files end with an empty line."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-113",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1133",
              "shortDescription": {
                "text": "Deprecated code should be removed"
              },
              "fullDescription": {
                "text": "This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1133",
              "properties": {
                "category": "Info Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1134",
              "shortDescription": {
                "text": "Track uses of \"FIXME\" tags"
              },
              "fullDescription": {
                "text": "FIXME tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1134",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1135",
              "shortDescription": {
                "text": "Track uses of \"TODO\" tags"
              },
              "fullDescription": {
                "text": "Developers often use TODO tags to mark areas in the code where additional work or improvements are needed but are not implemented immediately. However, these TODO tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to identify and address unattended TODO tags to ensure a clean and maintainable codebase. This description explores why this is a problem and how it can be fixed to improve the overall code quality."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1135",
              "properties": {
                "category": "Info Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "inSource"
                ],
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1144",
              "shortDescription": {
                "text": "Unused private types or members should be removed"
              },
              "fullDescription": {
                "text": "This rule raises an issue when a private/internal type or member is never referenced in the code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1144",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.156",
                "executionTimeInPercentage": "1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1147",
              "shortDescription": {
                "text": "Exit methods should not be called"
              },
              "fullDescription": {
                "text": "Calling Environment.Exit(exitCode) or Application.Exit() terminates the process and returns an exit code to the operating system.."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1147",
              "properties": {
                "category": "Blocker Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1151",
              "shortDescription": {
                "text": "\"switch case\" clauses should not have too many lines of code"
              },
              "fullDescription": {
                "text": "The switch statement should be used only to clearly define some new branches in the control flow. As soon as a case clause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of the case clause should be extracted into a dedicated method."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1151",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1155",
              "shortDescription": {
                "text": "\"Any()\" should be used to test for emptiness"
              },
              "fullDescription": {
                "text": "When you call Any(), it clearly communicates the code’s intention, which is to check if the collection is empty. Using Count() == 0 for this purpose is less direct and makes the code slightly more complex. However, there are some cases where special attention should be paid:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1155",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1163",
              "shortDescription": {
                "text": "Exceptions should not be thrown in finally blocks"
              },
              "fullDescription": {
                "text": "If an exception is already being thrown within the try block or caught in a catch block, throwing another exception in the finally block will override the original exception. This means that the original exception’s message and stack trace will be lost, potentially making it challenging to diagnose and troubleshoot the root cause of the problem."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1163",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1168",
              "shortDescription": {
                "text": "Empty arrays and collections should be returned instead of null"
              },
              "fullDescription": {
                "text": "Returning null or default instead of an actual collection forces the method callers to explicitly test for null, making the code more complex and less readable."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1168",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.078",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1172",
              "shortDescription": {
                "text": "Unused method parameters should be removed"
              },
              "fullDescription": {
                "text": "A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing function parameters that are not being utilized is considered best practice."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1172",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.050",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1185",
              "shortDescription": {
                "text": "Overriding members should do more than simply call the same member in the base class"
              },
              "fullDescription": {
                "text": "Overriding a method just to call the same method from the base class without performing any other actions is useless and misleading. The only time this is justified is in sealed overriding methods, where the effect is to lock in the parent class behavior. This rule ignores overrides of Equals and GetHashCode."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1185",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.028",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1186",
              "shortDescription": {
                "text": "Methods should not be empty"
              },
              "fullDescription": {
                "text": "An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1186",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1192",
              "shortDescription": {
                "text": "String literals should not be duplicated"
              },
              "fullDescription": {
                "text": "Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all occurrences."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1192",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1199",
              "shortDescription": {
                "text": "Nested code blocks should not be used"
              },
              "fullDescription": {
                "text": "Nested code blocks create new scopes where variables declared within are inaccessible from the outside, and their lifespan ends with the block."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1199",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1200",
              "shortDescription": {
                "text": "Classes should not be coupled to too many other classes"
              },
              "fullDescription": {
                "text": "According to the Single Responsibility Principle, introduced by Robert C. Martin in his book \"Principles of Object Oriented Design\", a class should have only one responsibility:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1200",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1206",
              "shortDescription": {
                "text": "\"Equals(Object)\" and \"GetHashCode()\" should be overridden in pairs"
              },
              "fullDescription": {
                "text": "Suppose you override Object.Equals in a type, you must also override Object.GetHashCode. If two objects are equal according to the Equals method, then calling GetHashCode on each of them must yield the same integer. If this is not the case, many collections, such as a Hashtable or a Dictionary won’t handle class instances correctly."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1206",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S121",
              "shortDescription": {
                "text": "Control structures should use curly braces"
              },
              "fullDescription": {
                "text": "Control structures are code statements that impact the program’s control flow (e.g., if statements, for loops, etc.)"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-121",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1210",
              "shortDescription": {
                "text": "\"Equals\" and the comparison operators should be overridden when implementing \"IComparable\""
              },
              "fullDescription": {
                "text": "When you implement IComparable or IComparable<T> on a class you should also override Equals(object) and overload the comparison operators (==, !=, <, <=, >, >=). That’s because the CLR cannot automatically call your CompareTo implementation from Equals(object) or from the base comparison operator implementations. Additionally, it is best practice to override GetHashCode along with Equals."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1210",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1215",
              "shortDescription": {
                "text": "\"GC.Collect\" should not be called"
              },
              "fullDescription": {
                "text": "GC.Collect is a method that forces or suggests to the garbage collector to run a collection of objects in the managed heap that are no longer being used and free their memory."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1215",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S122",
              "shortDescription": {
                "text": "Statements should be on separate lines"
              },
              "fullDescription": {
                "text": "Putting multiple statements on a single line lowers the code readability and makes debugging the code more complex."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-122",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1226",
              "shortDescription": {
                "text": "Method parameters, caught exceptions and foreach variables' initial values should not be ignored"
              },
              "fullDescription": {
                "text": "While it is technically correct to assign to parameters from within method bodies, doing so before the parameter value is read is likely a bug. Instead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as final, then at least read before reassignment."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1226",
              "properties": {
                "category": "Minor Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1227",
              "shortDescription": {
                "text": "break statements should not be used except for switch cases"
              },
              "fullDescription": {
                "text": "break; is an unstructured control flow statement which makes code harder to read."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1227",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1244",
              "shortDescription": {
                "text": "Floating point numbers should not be tested for equality"
              },
              "fullDescription": {
                "text": "Floating point numbers in C# (and in most other programming languages) are not precise. They are a binary approximation of the actual value. This means that even if two floating point numbers appear to be equal, they might not be due to the tiny differences in their binary representation."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1244",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S125",
              "shortDescription": {
                "text": "Sections of code should not be commented out"
              },
              "fullDescription": {
                "text": "Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never executed, it quickly becomes out of date and invalid."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-125",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S126",
              "shortDescription": {
                "text": "\"if ... else if\" constructs should end with \"else\" clauses"
              },
              "fullDescription": {
                "text": "This rule applies whenever an if statement is followed by one or more else if statements; the final else if should be followed by an else statement."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-126",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1264",
              "shortDescription": {
                "text": "A \"while\" loop should be used instead of a \"for\" loop"
              },
              "fullDescription": {
                "text": "When only the condition expression is defined in a for loop, and the initialization and increment expressions are missing, a while loop should be used instead to increase readability."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1264",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S127",
              "shortDescription": {
                "text": "\"for\" loop stop conditions should be invariant"
              },
              "fullDescription": {
                "text": "A for loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-127",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1301",
              "shortDescription": {
                "text": "\"switch\" statements should have at least 3 \"case\" clauses"
              },
              "fullDescription": {
                "text": "switch statements and expressions are useful when there are many different cases depending on the value of the same expression."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1301",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1309",
              "shortDescription": {
                "text": "Track uses of in-source issue suppressions"
              },
              "fullDescription": {
                "text": "This rule allows you to track the usage of the SuppressMessage attributes and #pragma warning disable mechanism."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1309",
              "properties": {
                "category": "Info Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S131",
              "shortDescription": {
                "text": "\"switch/Select\" statements should contain a \"default/Case Else\" clauses"
              },
              "fullDescription": {
                "text": "The requirement for a final default clause is defensive programming. The clause should either take appropriate action, or contain a suitable comment as to why no action is taken. Even when the switch covers all current values of an enum, a default case should still be used because there is no guarantee that the enum won’t be extended."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-131",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1312",
              "shortDescription": {
                "text": "Logger fields should be \"private static readonly\""
              },
              "fullDescription": {
                "text": "Regardless of the logging framework in use (Microsoft.Extension.Logging, Serilog, Log4net, NLog, …​​), logger fields should be:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1312",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1313",
              "shortDescription": {
                "text": "Using hardcoded IP addresses is security-sensitive"
              },
              "fullDescription": {
                "text": "Hardcoding IP addresses is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1313",
              "properties": {
                "category": "Major Security Hotspot",
                "executionTimeInSeconds": "0.017",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S134",
              "shortDescription": {
                "text": "Control flow statements \"if\", \"switch\", \"for\", \"foreach\", \"while\", \"do\"  and \"try\" should not be nested too deeply"
              },
              "fullDescription": {
                "text": "Nested control flow statements if, switch, for, foreach, while, do, and try are often key ingredients in creating what’s known as \"Spaghetti code\". This code smell can make your program difficult to understand and maintain."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-134",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S138",
              "shortDescription": {
                "text": "Functions should not have too many lines of code"
              },
              "fullDescription": {
                "text": "A function that grows too large tends to aggregate too many responsibilities."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-138",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1449",
              "shortDescription": {
                "text": "Culture should be specified for \"string\" operations"
              },
              "fullDescription": {
                "text": "string.ToLower(), ToUpper, IndexOf, LastIndexOf, and Compare are all culture-dependent, as are some (floating point number and DateTime-related) calls to ToString. Fortunately, all have variants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the system default culture, possibly creating problems with international characters."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1449",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1450",
              "shortDescription": {
                "text": "Private fields only used as local variables in methods should become local variables"
              },
              "fullDescription": {
                "text": "When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1450",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.023",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1451",
              "shortDescription": {
                "text": "Track lack of copyright and license headers"
              },
              "fullDescription": {
                "text": "Each source file should start with a header stating file ownership and the license which must be used to distribute the application."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1451",
              "properties": {
                "category": "Blocker Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1479",
              "shortDescription": {
                "text": "\"switch\" statements with many \"case\" clauses should have only one statement"
              },
              "fullDescription": {
                "text": "When switch statements have large sets of multi-line case clauses, the code becomes hard to read and maintain."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1479",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1481",
              "shortDescription": {
                "text": "Unused local variables should be removed"
              },
              "fullDescription": {
                "text": "An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code, contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain clarity and efficiency."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1481",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1541",
              "shortDescription": {
                "text": "Methods and properties should not be too complex"
              },
              "fullDescription": {
                "text": "The cyclomatic complexity of methods and properties should not exceed a defined threshold. Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1541",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1607",
              "shortDescription": {
                "text": "Tests should not be ignored"
              },
              "fullDescription": {
                "text": "When a test fails due, for example, to infrastructure issues, you might want to ignore it temporarily. But without some kind of notation about why the test is being ignored, it may never be reactivated. Such tests are difficult to address without comprehensive knowledge of the project, and end up polluting their projects."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1607",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1643",
              "shortDescription": {
                "text": "Strings should not be concatenated using '+' in a loop"
              },
              "fullDescription": {
                "text": "StringBuilder is more efficient than string concatenation, especially when the operator is repeated over and over as in loops."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1643",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1656",
              "shortDescription": {
                "text": "Variables should not be self-assigned"
              },
              "fullDescription": {
                "text": "Re-assigning a variable to itself is a defect as it has no actual effect and indicates meaning to do something else. It usually means that:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1656",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1659",
              "shortDescription": {
                "text": "Multiple variables should not be declared on the same line"
              },
              "fullDescription": {
                "text": "Declaring multiple variable on one line is difficult to read."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1659",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1694",
              "shortDescription": {
                "text": "An abstract class should have both abstract and concrete methods"
              },
              "fullDescription": {
                "text": "A class with only abstract methods and no inheritable behavior should be converted to an interface."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1694",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1696",
              "shortDescription": {
                "text": "NullReferenceException should not be caught"
              },
              "fullDescription": {
                "text": "Catching NullReferenceException is generally considered a bad practice because it can hide bugs in your code. Instead of catching this exception, you should aim to prevent it. This makes your code more robust and easier to understand. In addition, constantly catching and handling NullReferenceException can lead to performance issues. Exceptions are expensive in terms of system resources, so they should be used cautiously and only for exceptional conditions, not for regular control flow."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1696",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1698",
              "shortDescription": {
                "text": "\"==\" should not be used when \"Equals\" is overridden"
              },
              "fullDescription": {
                "text": "Using the equality == and inequality != operators to compare two objects generally works. The operators can be overloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on interface instances, then == resolves to reference equality, which may result in unexpected behavior if implementing classes override Equals. Similarly, when a class overrides Equals, but instances are compared with non-overloaded ==, there is a high chance that value comparison was meant instead of the reference one."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1698",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S1699",
              "shortDescription": {
                "text": "Constructors should only call non-overridable methods"
              },
              "fullDescription": {
                "text": "Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1699",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1751",
              "shortDescription": {
                "text": "Loops with at most one iteration should be refactored"
              },
              "fullDescription": {
                "text": "A loop statement with at most one iteration is equivalent to an if statement; the following block is executed only once."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1751",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1764",
              "shortDescription": {
                "text": "Identical expressions should not be used on both sides of operators"
              },
              "fullDescription": {
                "text": "Using the same value on both sides of certain operators is a code defect. In the case of logical operators, it is either a copy/paste error and, therefore, a bug, or it is simply duplicated code and should be simplified. For bitwise operators and most binary mathematical operators, having the same value on both sides of an operator yields predictable results and should be simplified as well to avoid further code defects."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1764",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.028",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1821",
              "shortDescription": {
                "text": "\"switch\" statements should not be nested"
              },
              "fullDescription": {
                "text": "Nested switch structures are difficult to understand because you can easily confuse the cases of an inner switch as belonging to an outer statement. Therefore nested switch statements should be avoided."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1821",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1848",
              "shortDescription": {
                "text": "Objects should not be created to be dropped immediately without being used"
              },
              "fullDescription": {
                "text": "Creating objects that are not used is a vulnerability that can lead to unexpected behavior."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1848",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1854",
              "shortDescription": {
                "text": "Unused assignments should be removed"
              },
              "fullDescription": {
                "text": "Dead stores refer to assignments made to local variables that are subsequently never used or immediately overwritten. Such assignments are unnecessary and don’t contribute to the functionality or clarity of the code. They may even negatively impact performance. Removing them enhances code cleanliness and readability. Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are - at best - a waste of computing resources."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1854",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.515",
                "executionTimeInPercentage": "3",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1858",
              "shortDescription": {
                "text": "\"ToString()\" calls should not be redundant"
              },
              "fullDescription": {
                "text": "Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. Similarly, explicitly invoking ToString() when the compiler would do it implicitly is also needless code-bloat."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1858",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S1862",
              "shortDescription": {
                "text": "Related \"if/else if\" statements should not have the same condition"
              },
              "fullDescription": {
                "text": "A chain of if/else if statements is evaluated from top to bottom. At most, only one branch will be executed: the first statement with a condition that evaluates to true. Therefore, duplicating a condition leads to unreachable code inside the duplicated condition block. Usually, this is due to a copy/paste error."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1862",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1871",
              "shortDescription": {
                "text": "Two branches in a conditional structure should not have exactly the same implementation"
              },
              "fullDescription": {
                "text": "When the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can potentially introduce bugs if one instance of the code is changed but others are not."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1871",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.033",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1905",
              "shortDescription": {
                "text": "Redundant casts should not be used"
              },
              "fullDescription": {
                "text": "Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in strongly typed languages like C, C++, C#, Java, Python, and others."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1905",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1939",
              "shortDescription": {
                "text": "Inheritance list should not be redundant"
              },
              "fullDescription": {
                "text": "An inheritance list entry is redundant if:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1939",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1940",
              "shortDescription": {
                "text": "Boolean checks should not be inverted"
              },
              "fullDescription": {
                "text": "It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1940",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1944",
              "shortDescription": {
                "text": "Invalid casts should be avoided"
              },
              "fullDescription": {
                "text": "A cast is an explicit conversion, which is a way to tell the compiler the intent to convert from one type to another."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1944",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.103",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S1994",
              "shortDescription": {
                "text": "\"for\" loop increment clauses should modify the loops' counters"
              },
              "fullDescription": {
                "text": "The for loop is designed to iterate over a range using a counter variable, with the counter being updated in the loop’s increment section. Misusing this structure can lead to issues such as infinite loops if the counter is not updated correctly. If this is intentional, use a while or do while loop instead of a for loop."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-1994",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2053",
              "shortDescription": {
                "text": "Password hashing functions should use an unpredictable salt"
              },
              "fullDescription": {
                "text": "This vulnerability increases the likelihood that attackers are able to compute the cleartext of password hashes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2053",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2068",
              "shortDescription": {
                "text": "Hard-coded credentials are security-sensitive"
              },
              "fullDescription": {
                "text": "Because it is easy to extract strings from an application source code or binary, credentials should not be hard-coded. This is particularly true for applications that are distributed or that are open-source."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2068",
              "properties": {
                "category": "Blocker Security Hotspot",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2077",
              "shortDescription": {
                "text": "Formatting SQL queries is security-sensitive"
              },
              "fullDescription": {
                "text": "Formatted SQL queries can be difficult to maintain, debug and can increase the risk of SQL injection when concatenating untrusted values into the query. However, this rule doesn’t detect SQL injections (unlike rule {rule:csharpsquid:S3649}), the goal is only to highlight complex/formatted queries."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2077",
              "properties": {
                "category": "Major Security Hotspot",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2092",
              "shortDescription": {
                "text": "Creating cookies without the \"secure\" flag is security-sensitive"
              },
              "fullDescription": {
                "text": "When a cookie is protected with the secure attribute set to true it will not be send by the browser over an unencrypted HTTP request and thus cannot be observed by an unauthorized person during a man-in-the-middle attack."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2092",
              "properties": {
                "category": "Minor Security Hotspot",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2094",
              "shortDescription": {
                "text": "Classes should not be empty"
              },
              "fullDescription": {
                "text": "There is no good excuse for an empty class. If it’s being used simply as a common extension point, it should be replaced with an interface. If it was stubbed in as a placeholder for future development it should be fleshed-out. In any other case, it should be eliminated."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2094",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2114",
              "shortDescription": {
                "text": "Collections should not be passed as arguments to their own methods"
              },
              "fullDescription": {
                "text": "Passing a collection as an argument to the collection’s own method is a code defect. Doing so might either have unexpected side effects or always have the same result."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2114",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2115",
              "shortDescription": {
                "text": "A secure password should be used when connecting to a database"
              },
              "fullDescription": {
                "text": "When accessing a database, an empty password should be avoided as it introduces a weakness."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2115",
              "properties": {
                "category": "Blocker Vulnerability",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2123",
              "shortDescription": {
                "text": "Values should not be uselessly incremented"
              },
              "fullDescription": {
                "text": "When using the postfix increment operator, it is important to know that the result of the expression x++ is the value before the operation x."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2123",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2139",
              "shortDescription": {
                "text": "Exceptions should be either logged or rethrown but not both"
              },
              "fullDescription": {
                "text": "When an exception is logged and rethrown, the upstream code may not be aware that the exception has already been logged. As a result, the same exception gets logged multiple times, making it difficult to identify the root cause of the issue. This can be particularly problematic in multi-threaded applications where messages from other threads can be interwoven with the repeated log entries."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2139",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2148",
              "shortDescription": {
                "text": "Underscores should be used to make large numbers readable"
              },
              "fullDescription": {
                "text": "Beginning with C# 7, it is possible to add underscores ('_') to numeric literals to enhance readability. The addition of underscores in this manner has no semantic meaning, but makes it easier for maintainers to understand the code."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2148",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2156",
              "shortDescription": {
                "text": "\"sealed\" classes should not have \"protected\" members"
              },
              "fullDescription": {
                "text": "The difference between private and protected visibility is that child classes can see and use protected members, but they cannot see private ones. Since a sealed class cannot have children, marking its members protected is confusingly pointless."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2156",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2166",
              "shortDescription": {
                "text": "Classes named like \"Exception\" should extend \"Exception\" or a subclass"
              },
              "fullDescription": {
                "text": "Clear, communicative naming is important in code. It helps maintainers and API users understand the intentions for and uses of a unit of code. Using \"exception\" in the name of a class that does not extend Exception or one of its subclasses is a clear violation of the expectation that a class' name will indicate what it is and/or does."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2166",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2178",
              "shortDescription": {
                "text": "Short-circuit logic should be used in boolean contexts"
              },
              "fullDescription": {
                "text": "Short-circuit evaluation is an evaluation strategy for Boolean operators, that doesn’t evaluates the second argument of the operator if it is not needed to determine the result of the operation."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2178",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2183",
              "shortDescription": {
                "text": "Integral numbers should not be shifted by zero or more than their number of bits-1"
              },
              "fullDescription": {
                "text": "The shifting operators are used to do an arithmetic shift to the bits of an integral numeric value, either to the left or the right."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2183",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "0.046",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2184",
              "shortDescription": {
                "text": "Results of integer division should not be assigned to floating point variables"
              },
              "fullDescription": {
                "text": "When division is performed on ints, the result will always be an int. You can assign that result to a double, float or decimal with automatic type conversion, but having started as an int, the result will likely not be what you expect. If the result of int division is assigned to a floating-point variable, precision will have been lost before the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2184",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2187",
              "shortDescription": {
                "text": "Test classes should contain at least one test case"
              },
              "fullDescription": {
                "text": "To ensure proper testing, it is important to include test cases in a test class. If a test class does not have any test cases, it can give the wrong impression that the class being tested has been thoroughly tested, when in reality, it has not."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2187",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2190",
              "shortDescription": {
                "text": "Loops and recursions should not be infinite"
              },
              "fullDescription": {
                "text": "Having an infinite loop or recursion will lead to a program failure or a program never finishing the execution."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2190",
              "properties": {
                "category": "Blocker Bug",
                "executionTimeInSeconds": "0.089",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2197",
              "shortDescription": {
                "text": "Modulus results should not be checked for direct equality"
              },
              "fullDescription": {
                "text": "When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for equality with a positive number (or a negative one) could result in unexpected results."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2197",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2198",
              "shortDescription": {
                "text": "Unnecessary mathematical comparisons should not be made"
              },
              "fullDescription": {
                "text": "Certain mathematical comparisons will always return the same value, and should not be performed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2198",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2201",
              "shortDescription": {
                "text": "Methods without side effects should not have their return values ignored"
              },
              "fullDescription": {
                "text": "When you do not use the return value of a method with no side effects, it indicates that something is wrong. Either this method is unnecessary, or the source code does not behave as expected and could lead to code defects. For example, there are methods, such as DateTime.AddYears, that don’t change the value of the input object, but instead, they return a new object whose value is the result of this operation, and as a result that you will have unexpected effects if you do not use the return value."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2201",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2219",
              "shortDescription": {
                "text": "Runtime type checking should be simplified"
              },
              "fullDescription": {
                "text": "To check the type of an object there are several options:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2219",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.020",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2221",
              "shortDescription": {
                "text": "\"Exception\" should not be caught"
              },
              "fullDescription": {
                "text": "Catching System.Exception seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types, including the ones that were not intended to be caught. To prevent any misunderstandings, exception filters should be used. Alternatively, each exception type should be in a separate catch block."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2221",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2222",
              "shortDescription": {
                "text": "Locks should be released on all paths"
              },
              "fullDescription": {
                "text": "To prevent potential deadlocks in an application, it is crucial to release any locks that are acquired within a method along all possible execution paths."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2222",
              "properties": {
                "category": "Critical Bug",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2223",
              "shortDescription": {
                "text": "Non-constant static fields should not be visible"
              },
              "fullDescription": {
                "text": "Unlike instance fields, which can only be accessed by code having a hold on the instance, static fields can be accessed by any code having visibility of the field and its type."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2223",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2225",
              "shortDescription": {
                "text": "\"ToString()\" method should not return null"
              },
              "fullDescription": {
                "text": "Calling ToString() on an object should always return a string. Thus, overriding the ToString method should never return null, as it breaks the method’s implicit contract, and as a result the consumer’s expectations."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2225",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2234",
              "shortDescription": {
                "text": "Arguments should be passed in the same order as the method parameters"
              },
              "fullDescription": {
                "text": "Calling a method with argument variables whose names match the method parameter names but in a different order can cause confusion. It could indicate a mistake in the arguments' order, leading to unexpected results."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2234",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.092",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2245",
              "shortDescription": {
                "text": "Using pseudorandom number generators (PRNGs) is security-sensitive"
              },
              "fullDescription": {
                "text": "Using pseudorandom number generators (PRNGs) is security-sensitive. For example, it has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2245",
              "properties": {
                "category": "Critical Security Hotspot",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2251",
              "shortDescription": {
                "text": "A \"for\" loop update clause should move the counter in the right direction"
              },
              "fullDescription": {
                "text": "A for loop with a counter that moves in the wrong direction, away from the stop condition, is not an infinite loop. Because of wraparound, the loop will eventually reach its stop condition, but in doing so, it will probably run more times than anticipated, potentially causing unexpected behavior."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2251",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2252",
              "shortDescription": {
                "text": "For-loop conditions should be true at least once"
              },
              "fullDescription": {
                "text": "A for loop is a fundamental programming construct used to execute a block of code repeatedly. However, if the loop’s condition is false before the first iteration, the loop will never execute."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2252",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2257",
              "shortDescription": {
                "text": "Using non-standard cryptographic algorithms is security-sensitive"
              },
              "fullDescription": {
                "text": "The use of a non-standard algorithm is dangerous because a determined attacker may be able to break the algorithm and compromise whatever data has been protected. Standard algorithms like AES, RSA, SHA, …​ should be used instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2257",
              "properties": {
                "category": "Critical Security Hotspot",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2259",
              "shortDescription": {
                "text": "Null pointers should not be dereferenced"
              },
              "fullDescription": {
                "text": "Accessing a null value will always throw a NullReferenceException most likely causing an abrupt program termination."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2259",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2275",
              "shortDescription": {
                "text": "Composite format strings should not lead to unexpected behavior at runtime"
              },
              "fullDescription": {
                "text": "Composite format strings in C# are evaluated at runtime, which means they are not verified by the compiler. Introducing an ill-formed format item, or indexing mismatch can lead to unexpected behaviors or runtime errors. The purpose of this rule is to perform static validation on composite format strings used in various string formatting functions to ensure their correct usage. This rule validates the proper behavior of composite formats when invoking the following methods:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2275",
              "properties": {
                "category": "Blocker Bug",
                "executionTimeInSeconds": "0.028",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2290",
              "shortDescription": {
                "text": "Field-like events should not be virtual"
              },
              "fullDescription": {
                "text": "Field-like events are events that do not have explicit add and remove accessors."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2290",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2291",
              "shortDescription": {
                "text": "Overflow checking should not be disabled for \"Enumerable.Sum\""
              },
              "fullDescription": {
                "text": "Enumerable.Sum() always executes addition in a checked context, so an OverflowException will be thrown if the value exceeds MaxValue, even if an unchecked context was specified. Therefore, using this method inside an unchecked context will only make the code more confusing, since the behavior will still be checked."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2291",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2292",
              "shortDescription": {
                "text": "Trivial properties should be auto-implemented"
              },
              "fullDescription": {
                "text": "Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented properties, yielding cleaner and more readable code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2292",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.109",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2302",
              "shortDescription": {
                "text": "\"nameof\" should be used"
              },
              "fullDescription": {
                "text": "Because parameter names could be changed during refactoring, they should not be spelled out literally in strings. Instead, use nameof(), and the string that’s output will always be correct."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2302",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2306",
              "shortDescription": {
                "text": "\"async\" and \"await\" should not be used as identifiers"
              },
              "fullDescription": {
                "text": "Since C# 5.0, async and await are contextual keywords. Contextual keywords do have a particular meaning in some contexts, but are not reserved and therefore can be used as variable names."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2306",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.026",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2325",
              "shortDescription": {
                "text": "Methods and properties that don't access instance data should be static"
              },
              "fullDescription": {
                "text": "Methods and properties that don’t access instance data can be static to prevent any misunderstanding about the contract of the method."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2325",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2326",
              "shortDescription": {
                "text": "Unused type parameters should be removed"
              },
              "fullDescription": {
                "text": "Type parameters that aren’t used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type parameters should be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2326",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.045",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2327",
              "shortDescription": {
                "text": "\"try\" statements with identical \"catch\" and/or \"finally\" blocks should be merged"
              },
              "fullDescription": {
                "text": "When multiple, adjacent try statements have duplicate catch and/or finally blocks, they should be merged to consolidate the catch/finally logic for cleaner, more readable code. Note that this applies even when there is intervening code outside any try block."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2327",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2328",
              "shortDescription": {
                "text": "\"GetHashCode\" should not reference mutable fields"
              },
              "fullDescription": {
                "text": "GetHashCode is used to file an object in a Dictionary or Hashtable. If GetHashCode uses non-readonly fields and those fields change after the object is stored, the object immediately becomes mis-filed in the Hashtable. Any subsequent test to see if the object is in the Hashtable will return a false negative."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2328",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2330",
              "shortDescription": {
                "text": "Array covariance should not be used"
              },
              "fullDescription": {
                "text": "Array covariance is the principle that if an implicit or explicit reference conversion exits from type A to B, then the same conversion exists from the array type A[] to B[]."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2330",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2333",
              "shortDescription": {
                "text": "Redundant modifiers should not be used"
              },
              "fullDescription": {
                "text": "Unnecessary keywords simply clutter the code and should be removed. Specifically:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2333",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2339",
              "shortDescription": {
                "text": "Public constant members should not be used"
              },
              "fullDescription": {
                "text": "Constant members are copied at compile time to the call sites, instead of being fetched at runtime."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2339",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2342",
              "shortDescription": {
                "text": "Enumeration types should comply with a naming convention"
              },
              "fullDescription": {
                "text": "Shared naming conventions allow teams to collaborate efficiently. This rule checks that all enum names match a provided regular expression."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2342",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2344",
              "shortDescription": {
                "text": "Enumeration type names should not have \"Flags\" or \"Enum\" suffixes"
              },
              "fullDescription": {
                "text": "The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2344",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2345",
              "shortDescription": {
                "text": "Flags enumerations should explicitly initialize all their members"
              },
              "fullDescription": {
                "text": "When you annotate an Enum with the Flags attribute, you must not rely on the values that are automatically set by the language to the Enum members, but you should define the enumeration constants in powers of two (1, 2, 4, 8, and so on). Automatic value initialization will set the first member to zero and increment the value by one for each subsequent member. As a result, you won’t be able to use the enum members with bitwise operators."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2345",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2346",
              "shortDescription": {
                "text": "Flags enumerations zero-value members should be named \"None\""
              },
              "fullDescription": {
                "text": "An enumeration can be decorated with the FlagsAttribute to indicate that it can be used as a bit field: a set of flags, that can be independently set and reset."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2346",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2357",
              "shortDescription": {
                "text": "Fields should be private"
              },
              "fullDescription": {
                "text": "Fields should not be part of an API, and therefore should always be private. Indeed, they cannot be added to an interface for instance, and validation cannot be added later on without breaking backward compatibility. Instead, developers should encapsulate their fields into properties. Explicit property getters and setters can be introduced for validation purposes or to smooth the transition to a newer system."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2357",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2360",
              "shortDescription": {
                "text": "Optional parameters should not be used"
              },
              "fullDescription": {
                "text": "The overloading mechanism should be used in place of optional parameters for several reasons:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2360",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2365",
              "shortDescription": {
                "text": "Properties should not make collection or array copies"
              },
              "fullDescription": {
                "text": "Most developers expect property access to be as efficient as field access. However, if a property returns a copy of an array or collection, it will be much slower than a simple field access, contrary to the caller’s likely expectations. Therefore, such properties should be refactored into methods so that callers are not surprised by the unexpectedly poor performance."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2365",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.050",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2368",
              "shortDescription": {
                "text": "Public methods should not have multidimensional array parameters"
              },
              "fullDescription": {
                "text": "Using multidimensional and jagged arrays as method parameters in C# can be challenging for developers."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2368",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.034",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2372",
              "shortDescription": {
                "text": "Exceptions should not be thrown from property getters"
              },
              "fullDescription": {
                "text": "Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a method."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2372",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2376",
              "shortDescription": {
                "text": "Write-only properties should not be used"
              },
              "fullDescription": {
                "text": "Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or the property should be replaced with a setter method."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2376",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.033",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2386",
              "shortDescription": {
                "text": "Mutable fields should not be \"public static\""
              },
              "fullDescription": {
                "text": "public static mutable fields of classes which are accessed directly should be protected to the degree possible. This can be done by reducing the accessibility of the field or by changing the return type to an immutable type."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2386",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2387",
              "shortDescription": {
                "text": "Child class fields should not shadow parent class fields"
              },
              "fullDescription": {
                "text": "Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you’ll get confusion at best, chaos at worst."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2387",
              "properties": {
                "category": "Blocker Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2436",
              "shortDescription": {
                "text": "Types and methods should not have too many generic parameters"
              },
              "fullDescription": {
                "text": "A method or class with too many type parameters has likely aggregated too many responsibilities and should be split."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2436",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2437",
              "shortDescription": {
                "text": "Unnecessary bit operations should not be performed"
              },
              "fullDescription": {
                "text": "Certain bitwise operations are not needed and should not be performed because their results are predictable."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2437",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay",
                  "Unnecessary"
                ]
              }
            },
            {
              "id": "S2445",
              "shortDescription": {
                "text": "Blocks should be synchronized on read-only fields"
              },
              "fullDescription": {
                "text": "Locking on a class field synchronizes not on the field itself, but on the object assigned to it. Thus, there are some good practices to follow to avoid problems related to thread synchronization."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2445",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2479",
              "shortDescription": {
                "text": "Whitespace and control characters in string literals should be explicit"
              },
              "fullDescription": {
                "text": "Non-encoded control characters and whitespace characters are often injected in the source code because of a bad manipulation. They are either invisible or difficult to recognize, which can result in bugs when the string is not what the developer expects. If you actually need to use a control character use their encoded version:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2479",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2486",
              "shortDescription": {
                "text": "Generic exceptions should not be ignored"
              },
              "fullDescription": {
                "text": "When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2486",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2551",
              "shortDescription": {
                "text": "Shared resources should not be used for locking"
              },
              "fullDescription": {
                "text": "A shared resource refers to a resource or data that can be accessed or modified by multiple threads or concurrent parts of a program. It could be any piece of data, object, file, database connection, or system resource that needs to be accessed or manipulated by multiple parts of a program at the same time."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2551",
              "properties": {
                "category": "Critical Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2583",
              "shortDescription": {
                "text": "Conditionally executed code should be reachable"
              },
              "fullDescription": {
                "text": "Conditional expressions which are always true or false can lead to unreachable code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2583",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2589",
              "shortDescription": {
                "text": "Boolean expressions should not be gratuitous"
              },
              "fullDescription": {
                "text": "Gratuitous boolean expressions are conditions that do not change the evaluation of a program. This issue can indicate logical errors and affect the correctness of an application, as well as its maintainability."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2589",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2612",
              "shortDescription": {
                "text": "Setting loose file permissions is security-sensitive"
              },
              "fullDescription": {
                "text": "In Unix, \"others\" class refers to all users except the owner of the file and the members of the group assigned to this file."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2612",
              "properties": {
                "category": "Major Security Hotspot",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2629",
              "shortDescription": {
                "text": "Logging templates should be constant"
              },
              "fullDescription": {
                "text": "Logging arguments should not require evaluation in order to avoid unnecessary performance overhead. When passing concatenated strings or string interpolations directly into a logging method, the evaluation of these expressions occurs every time the logging method is called, regardless of the log level. This can lead to inefficient code execution and increased resource consumption."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2629",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2674",
              "shortDescription": {
                "text": "The length returned from a stream read should be checked"
              },
              "fullDescription": {
                "text": "You cannot assume that any given stream reading call will fill the byte[] passed in to the method with the number of bytes requested. Instead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce a bug that is both harmful and difficult to reproduce."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2674",
              "properties": {
                "category": "Minor Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2681",
              "shortDescription": {
                "text": "Multiline blocks should be enclosed in curly braces"
              },
              "fullDescription": {
                "text": "Having inconsistent indentation and omitting curly braces from a control structure, such as an if statement or for loop, is misleading and can induce bugs."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2681",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.030",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2688",
              "shortDescription": {
                "text": "\"NaN\" should not be used in comparisons"
              },
              "fullDescription": {
                "text": "double.NaN and float.NaN are not equal to anything, not even themselves."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2688",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2692",
              "shortDescription": {
                "text": "\"IndexOf\" checks should not be for positive numbers"
              },
              "fullDescription": {
                "text": "Most checks against an IndexOf value compare it with -1 because 0 is a valid index."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2692",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2696",
              "shortDescription": {
                "text": "Instance members should not write to \"static\" fields"
              },
              "fullDescription": {
                "text": "This rule raises an issue each time a static field is updated from a non-static method or property."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2696",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2699",
              "shortDescription": {
                "text": "Tests should include assertions"
              },
              "fullDescription": {
                "text": "The rule targets test methods that lack an assertion and consist solely of an action and, optionally, a setup."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2699",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2701",
              "shortDescription": {
                "text": "Literal boolean values should not be used in assertions"
              },
              "fullDescription": {
                "text": "Using literal boolean values in assertions can lead to less readable and less informative unit tests. When a test fails, it’s important to have a clear understanding of what the test was checking and why it failed. Most of the testing frameworks provide more explicit assertion methods that will provide a more helpful error message if the test fails."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2701",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2737",
              "shortDescription": {
                "text": "\"catch\" clauses should do more than rethrow"
              },
              "fullDescription": {
                "text": "A catch clause that only rethrows the caught exception has the same effect as omitting the catch altogether and letting it bubble up automatically."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2737",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2743",
              "shortDescription": {
                "text": "Static fields should not be used in generic types"
              },
              "fullDescription": {
                "text": "A static field in a generic type is not shared among instances of different closed constructed types, thus LengthLimitedSingletonCollection<int>.instances and LengthLimitedSingletonCollection<string>.instances will point to different objects, even though instances is seemingly shared among all LengthLimitedSingletonCollection<> generic classes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2743",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.022",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2755",
              "shortDescription": {
                "text": "XML parsers should not be vulnerable to XXE attacks"
              },
              "fullDescription": {
                "text": "This vulnerability allows the usage of external entities in XML."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2755",
              "properties": {
                "category": "Blocker Vulnerability",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2757",
              "shortDescription": {
                "text": "Non-existent operators like \"=+\" should not be used"
              },
              "fullDescription": {
                "text": "Using operator pairs (=+, =-, or =!) that look like reversed single operators (+=, -= or !=) is confusing. They compile and run but do not produce the same result as their mirrored counterpart."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2757",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2760",
              "shortDescription": {
                "text": "Sequential tests should not check the same condition"
              },
              "fullDescription": {
                "text": "When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition should have been checked in the second test."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2760",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2761",
              "shortDescription": {
                "text": "Doubled prefix operators \"!!\" and \"~~\" should not be used"
              },
              "fullDescription": {
                "text": "The repetition of a prefix operator (!, or ~) is usually a typo. The second operator invalidates the first one."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2761",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2857",
              "shortDescription": {
                "text": "SQL keywords should be delimited by whitespace"
              },
              "fullDescription": {
                "text": "When concatenating strings, it is very easy to forget a whitespace."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2857",
              "properties": {
                "category": "Blocker Bug",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2925",
              "shortDescription": {
                "text": "\"Thread.Sleep\" should not be used in tests"
              },
              "fullDescription": {
                "text": "Using Thread.Sleep in a test might introduce unpredictable and inconsistent results depending on the environment. Furthermore, it will block the thread, which means the system resources are not being fully used."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2925",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2930",
              "shortDescription": {
                "text": "\"IDisposables\" should be disposed"
              },
              "fullDescription": {
                "text": "When writing managed code, there is no need to worry about memory allocation or deallocation as it is taken care of by the garbage collector. However, certain objects, such as Bitmap, utilize unmanaged memory for specific purposes like pointer arithmetic. These objects may have substantial unmanaged memory footprints while having minimal managed footprints. Unfortunately, the garbage collector only recognizes the small managed footprint and does not promptly reclaim the corresponding unmanaged memory (by invoking the finalizer method of Bitmap) for efficiency reasons."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2930",
              "properties": {
                "category": "Blocker Bug",
                "executionTimeInSeconds": "0.041",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2931",
              "shortDescription": {
                "text": "Classes with \"IDisposable\" members should implement \"IDisposable\""
              },
              "fullDescription": {
                "text": "An IDisposable object should be disposed (there are some rare exceptions where not disposing is fine, most notably Task). If a class has an IDisposable field, there can be two situations:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2931",
              "properties": {
                "category": "Blocker Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S2933",
              "shortDescription": {
                "text": "Fields that are only assigned in the constructor should be \"readonly\""
              },
              "fullDescription": {
                "text": "readonly fields can only be assigned in a class constructor. If a class has a field that’s not marked readonly but is only set in the constructor, it could cause confusion about the field’s intended use. To avoid confusion, such fields should be marked readonly to make their intended use explicit, and to prevent future maintainers from inadvertently changing their use."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2933",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.053",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2934",
              "shortDescription": {
                "text": "Property assignments should not be made for \"readonly\" fields not constrained to reference types"
              },
              "fullDescription": {
                "text": "While the properties of a readonly reference type field can still be changed after initialization, those of a readonly value type field, such as a struct, cannot."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2934",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2952",
              "shortDescription": {
                "text": "Classes should \"Dispose\" of members from the classes' own \"Dispose\" methods"
              },
              "fullDescription": {
                "text": "It is possible in an IDisposable to call Dispose on class members from any method, but the contract of Dispose is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource leaks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2952",
              "properties": {
                "category": "Critical Bug",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S2953",
              "shortDescription": {
                "text": "Methods named \"Dispose\" should implement \"IDisposable.Dispose\""
              },
              "fullDescription": {
                "text": "IDisposable is an interface implemented by all types which need to provide a mechanism for releasing unmanaged resources."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2953",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2955",
              "shortDescription": {
                "text": "Generic parameters not constrained to reference types should not be compared to \"null\""
              },
              "fullDescription": {
                "text": "In C#, without constraints on a generic type parameter, both reference and value types can be passed. However, comparing this type parameter to null can be misleading as value types, like struct, can never be null."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2955",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2970",
              "shortDescription": {
                "text": "Assertions should be complete"
              },
              "fullDescription": {
                "text": "This rule addresses the issue of incomplete assertions that can occur when using certain test frameworks. Incomplete assertions can lead to tests that do not effectively verify anything. The rule enforces the use of complete assertions in specific cases, namely:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2970",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2971",
              "shortDescription": {
                "text": "LINQ expressions should be simplified"
              },
              "fullDescription": {
                "text": "In the interests of readability, code that can be simplified should be simplified. To that end, there are several ways IEnumerable language integrated queries (LINQ) can be simplified. This not only improves readabilty but can also lead to improved performance."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2971",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.045",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2995",
              "shortDescription": {
                "text": "\"Object.ReferenceEquals\" should not be used for value types"
              },
              "fullDescription": {
                "text": "In C#, the Object.ReferenceEquals method is used to compare two reference type variables. If you use this method to compare two value types, such as int, float, or bool you will not get the expected results because value type variables contain an instance of the type and not a reference to it."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2995",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2996",
              "shortDescription": {
                "text": "\"ThreadStatic\" fields should not be initialized"
              },
              "fullDescription": {
                "text": "When an object has a field annotated with ThreadStatic, that field is shared within a given thread, but unique across threads. Since a class' static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial values."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2996",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S2997",
              "shortDescription": {
                "text": "\"IDisposables\" created in a \"using\" statement should not be returned"
              },
              "fullDescription": {
                "text": "When you use a using statement, the goal is to ensure the correct disposal of an IDisposable instance when the control leaves the using statement block."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-2997",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3005",
              "shortDescription": {
                "text": "\"ThreadStatic\" should not be used on non-static fields"
              },
              "fullDescription": {
                "text": "When you annotate a field with the ThreadStatic attribute, it is an indication that the value of this field is unique for each thread. But if you don’t mark the field as static, then the ThreadStatic attribute is ignored."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3005",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3010",
              "shortDescription": {
                "text": "Static fields should not be updated in constructors"
              },
              "fullDescription": {
                "text": "Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all instances of the class."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3010",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3011",
              "shortDescription": {
                "text": "Reflection should not be used to increase accessibility of classes, methods, or fields"
              },
              "fullDescription": {
                "text": "Altering or bypassing the accessibility of classes, methods, or fields through reflection violates the encapsulation principle. This can break the internal contracts of the accessed target and lead to maintainability issues and runtime errors."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3011",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.029",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3052",
              "shortDescription": {
                "text": "Members should not be initialized to default values"
              },
              "fullDescription": {
                "text": "The compiler automatically initializes class fields, auto-properties and events to their default values before setting them with any initialization values, so there is no need to explicitly set a member to its default value. Further, under the logic that cleaner code is better code, it’s considered poor style to do so."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3052",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3059",
              "shortDescription": {
                "text": "Types should not have members with visibility set higher than the type's visibility"
              },
              "fullDescription": {
                "text": "There’s no point in having a public member in a non-public type because objects that can’t access the type will never have the chance to access the member."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3059",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3060",
              "shortDescription": {
                "text": "\"is\" should not be used with \"this\""
              },
              "fullDescription": {
                "text": "One of the possible ways of performing type-testing is via the is operator: food is Pizza."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3060",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3063",
              "shortDescription": {
                "text": "\"StringBuilder\" data should be used"
              },
              "fullDescription": {
                "text": "StringBuilder instances that never build a string clutter the code and worse are a drag on performance. Either they should be removed, or the missing ToString() call should be added."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3063",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3168",
              "shortDescription": {
                "text": "\"async\" methods should not return \"void\""
              },
              "fullDescription": {
                "text": "An async method with a void return type does not follow the task asynchronous programming (TAP) model since the return type should be Task or Task<TResult>"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3168",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3169",
              "shortDescription": {
                "text": "Multiple \"OrderBy\" calls should not be used"
              },
              "fullDescription": {
                "text": "There’s no point in chaining multiple OrderBy calls in a LINQ; only the last one will be reflected in the result because each subsequent call completely reorders the list. Thus, calling OrderBy multiple times is a performance issue as well, because all of the sorting will be executed, but only the result of the last sort will be kept."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3169",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3172",
              "shortDescription": {
                "text": "Delegates should not be subtracted"
              },
              "fullDescription": {
                "text": "In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3172",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3215",
              "shortDescription": {
                "text": "\"interface\" instances should not be cast to concrete types"
              },
              "fullDescription": {
                "text": "Needing to cast from an interface to a concrete type indicates that something is wrong with the abstractions in use, likely that something is missing from the interface. Instead of casting to a discrete type, the missing functionality should be added to the interface. Otherwise there is a risk of runtime exceptions."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3215",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3216",
              "shortDescription": {
                "text": "\"ConfigureAwait(false)\" should be used"
              },
              "fullDescription": {
                "text": "After an awaited Task has executed, you can continue execution in the original, calling thread or any arbitrary thread. Unless the rest of the code needs the context from which the Task was spawned, Task.ConfigureAwait(false) should be used to keep execution in the Task thread to avoid the need for context switching and the possibility of deadlocks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3216",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3217",
              "shortDescription": {
                "text": "\"Explicit\" conversions of \"foreach\" loops should not be used"
              },
              "fullDescription": {
                "text": "The foreach statement was introduced in the C# language prior to generics to make it easier to work with the non-generic collections available at that time such as ArrayList. The foreach statements allow you to downcast elements of a collection of Objects to any other type."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3217",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3218",
              "shortDescription": {
                "text": "Inner class members should not shadow outer class \"static\" or type members"
              },
              "fullDescription": {
                "text": "Naming the members of an inner class the same as the static members of its enclosing class is possible but generally considered a bad practice. That’s because maintainers may be confused about which members are being used in a given context. Instead the inner class member should be given distinct and descriptive name, and all references to it should be updated accordingly."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3218",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3220",
              "shortDescription": {
                "text": "Method calls should not resolve ambiguously to overloads with \"params\""
              },
              "fullDescription": {
                "text": "The rules for method resolution are complex and perhaps not properly understood by all coders. The params keyword can make method declarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different methods."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3220",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3234",
              "shortDescription": {
                "text": "\"GC.SuppressFinalize\" should not be invoked for types without destructors"
              },
              "fullDescription": {
                "text": "GC.SuppressFinalize asks the Common Language Runtime not to call the finalizer of an object. This is useful when implementing the dispose pattern where object finalization is already handled in IDisposable.Dispose. However, it has no effect if there is no finalizer defined in the object’s type, so using it in such cases is just confusing."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3234",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3235",
              "shortDescription": {
                "text": "Redundant parentheses should not be used"
              },
              "fullDescription": {
                "text": "Redundant parentheses are simply wasted keystrokes, and should be removed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3235",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3236",
              "shortDescription": {
                "text": "Caller information arguments should not be provided explicitly"
              },
              "fullDescription": {
                "text": "Caller information attributes: CallerFilePathAttribute, CallerLineNumberAttribute, and CallerArgumentExpressionAttribute provide a way to get information about the caller of a method through optional parameters. But the arguments for these optional parameters are only generated if they are not explicitly defined in the call. Thus, specifying the argument values defeats the purpose of the attributes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3236",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.040",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3237",
              "shortDescription": {
                "text": "\"value\" contextual keyword should be used"
              },
              "fullDescription": {
                "text": "When you need to get external input for set and init methods defined for properties and indexers or for remove and add methods for events, you should always get this input throught the value contextual keyword."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3237",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3240",
              "shortDescription": {
                "text": "The simplest possible condition syntax should be used"
              },
              "fullDescription": {
                "text": "In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3240",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3241",
              "shortDescription": {
                "text": "Methods should not return values that are never used"
              },
              "fullDescription": {
                "text": "Private methods are intended for use only within their scope. If these methods return values that are not utilized by any calling functions, it indicates that the return operation is unnecessary. Removing such returns can enhance both efficiency and code clarity."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3241",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.043",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3242",
              "shortDescription": {
                "text": "Method parameters should be declared with base types"
              },
              "fullDescription": {
                "text": "When a derived type is used as a parameter instead of the base type, it limits the uses of the method. If the additional functionality that is provided in the derived type is not required then that limitation isn’t required, and should be removed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3242",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3244",
              "shortDescription": {
                "text": "Anonymous delegates should not be used to unsubscribe from Events"
              },
              "fullDescription": {
                "text": "When working with anonymous functions, it is important to keep in mind that each time you create one, it is a completely new instance."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3244",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3246",
              "shortDescription": {
                "text": "Generic type parameters should be co/contravariant when possible"
              },
              "fullDescription": {
                "text": "In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the out and in modifiers when possible to make the interfaces and delegates covariant and contravariant, respectively."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3246",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3247",
              "shortDescription": {
                "text": "Duplicate casts should not be made"
              },
              "fullDescription": {
                "text": "Because the is operator performs a cast if the object is not null, using is to check type and then casting the same argument to that type, necessarily performs two casts. The same result can be achieved more efficiently with a single cast using as, followed by a null-check."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3247",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.097",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3249",
              "shortDescription": {
                "text": "Classes directly extending \"object\" should not call \"base\" in \"GetHashCode\" or \"Equals\""
              },
              "fullDescription": {
                "text": "Making a base call when overriding a method is generally a good idea, but not in the case of GetHashCode and Equals for classes that directly extend Object. These methods are based on the object’s reference, meaning that no two objects that use those base methods can be equal or have the same hash."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3249",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3251",
              "shortDescription": {
                "text": "Implementations should be provided for \"partial\" methods"
              },
              "fullDescription": {
                "text": "partial methods allow an increased degree of flexibility in programming a system. Hooks can be added to generated code by invoking methods that define their signature, but might not have an implementation yet. But if the implementation is still missing when the code makes it to production, the compiler silently removes the call. In the best case scenario, such calls simply represent cruft, but in they worst case they are critical, missing functionality, the loss of which will lead to unexpected results at runtime."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3251",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3253",
              "shortDescription": {
                "text": "Constructor and destructor declarations should not be redundant"
              },
              "fullDescription": {
                "text": "Since the compiler will automatically invoke the base type’s no-argument constructor, there’s no need to specify its invocation explicitly. Also, when only a single public parameterless constructor is defined in a class, then that constructor can be removed because the compiler would generate it automatically. Similarly, empty static constructors and empty destructors are also wasted keystrokes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3253",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3254",
              "shortDescription": {
                "text": "Default parameter values should not be passed as arguments"
              },
              "fullDescription": {
                "text": "Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3254",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3256",
              "shortDescription": {
                "text": "\"string.IsNullOrEmpty\" should be used"
              },
              "fullDescription": {
                "text": "Using string.Equals to determine if a string is empty is significantly slower than using string.IsNullOrEmpty() or checking for string.Length == 0. string.IsNullOrEmpty() is both clear and concise, and therefore preferred to laborious, error-prone, manual null- and emptiness-checking."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3256",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3257",
              "shortDescription": {
                "text": "Declarations and initializations should be as concise as possible"
              },
              "fullDescription": {
                "text": "In C#, the type of a variable can often be inferred by the compiler. The use of the [var keyword](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables) allows you to avoid repeating the type name in a variable declaration and object instantiation because the declared type can often be inferred by the compiler."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3257",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3260",
              "shortDescription": {
                "text": "Non-derived \"private\" classes and records should be \"sealed\""
              },
              "fullDescription": {
                "text": "Classes and records with either private or file access modifiers aren’t visible outside of their assemblies or files, so if they’re not extended inside their scope, they should be made explicitly non-extensible with the addition of the sealed keyword."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3260",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.021",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3261",
              "shortDescription": {
                "text": "Namespaces should not be empty"
              },
              "fullDescription": {
                "text": "Namespaces with no lines of code clutter a project and should be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3261",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.047",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3262",
              "shortDescription": {
                "text": "\"params\" should be used on overrides"
              },
              "fullDescription": {
                "text": "Overriding methods automatically inherit the params behavior. To ease readability, this modifier should be explicitly used in the overriding method as well."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3262",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.026",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3263",
              "shortDescription": {
                "text": "Static fields should appear in the order they must be initialized "
              },
              "fullDescription": {
                "text": "Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class above the field or fields required for its initialization will yield unexpected results."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3263",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3264",
              "shortDescription": {
                "text": "Events should be invoked"
              },
              "fullDescription": {
                "text": "Events that are not invoked anywhere are dead code, and there’s no good reason to keep them in the source."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3264",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3265",
              "shortDescription": {
                "text": "Non-flags enums should not be used in bitwise operations"
              },
              "fullDescription": {
                "text": "Enumerations are commonly used to identify distinct elements from a set of values."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3265",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3267",
              "shortDescription": {
                "text": "Loops should be simplified with \"LINQ\" expressions"
              },
              "fullDescription": {
                "text": "When a loop is filtering, selecting or aggregating, those functions can be handled with a clearer, more concise LINQ expression instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3267",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.018",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3329",
              "shortDescription": {
                "text": "Cipher Block Chaining IVs should be unpredictable"
              },
              "fullDescription": {
                "text": "This vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3329",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3330",
              "shortDescription": {
                "text": "Creating cookies without the \"HttpOnly\" flag is security-sensitive"
              },
              "fullDescription": {
                "text": "When a cookie is configured with the HttpOnly attribute set to true, the browser guaranties that no client-side script will be able to read it. In most cases, when a cookie is created, the default value of HttpOnly is false and it’s up to the developer to decide whether or not the content of the cookie can be read by the client-side script. As a majority of Cross-Site Scripting (XSS) attacks target the theft of session-cookies, the HttpOnly attribute can help to reduce their impact as it won’t be possible to exploit the XSS vulnerability to steal session-cookies."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3330",
              "properties": {
                "category": "Minor Security Hotspot",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3343",
              "shortDescription": {
                "text": "Caller information parameters should come at the end of the parameter list"
              },
              "fullDescription": {
                "text": "Caller information attributes provide a way to get information about the caller of a method through optional parameters. But they only work right if their values aren’t provided explicitly. So if you define a method with caller info attributes in the middle of the parameter list, the caller is forced to use named arguments if they want to use the method properly."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3343",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3346",
              "shortDescription": {
                "text": "Expressions used in \"Debug.Assert\" should not produce side effects"
              },
              "fullDescription": {
                "text": "An assertion is a piece of code that’s used during development when the compilation debug mode is activated. It allows a program to check itself as it runs. When an assertion is true, that means everything is operating as expected."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3346",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3353",
              "shortDescription": {
                "text": "Unchanged variables should be marked as \"const\""
              },
              "fullDescription": {
                "text": "If a variable that is not supposed to change is not marked as const, it could be accidentally reassigned elsewhere in the code, leading to unexpected behavior and bugs that can be hard to track down."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3353",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3358",
              "shortDescription": {
                "text": "Ternary operators should not be nested"
              },
              "fullDescription": {
                "text": "Nested ternaries are hard to read and can make the order of operations complex to understand."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3358",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3363",
              "shortDescription": {
                "text": "Date and time should not be used as a type for primary keys"
              },
              "fullDescription": {
                "text": "You should only set a property of a temporal type (like DateTime or DateTimeOffset) as the primary key of a table if the values are guaranteed to be unique."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3363",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3366",
              "shortDescription": {
                "text": "\"this\" should not be exposed from constructors"
              },
              "fullDescription": {
                "text": "In single-threaded environments, the use of this in constructors is normal, and expected. But in multi-threaded environments, it could expose partially-constructed objects to other threads, and should be used with caution."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3366",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3376",
              "shortDescription": {
                "text": "Attribute, EventArgs, and Exception type names should end with the type being extended"
              },
              "fullDescription": {
                "text": "Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance, class FirstAttribute : Attribute can be used simply with First, but you must use the full name for class AttributeOne : Attribute."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3376",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3397",
              "shortDescription": {
                "text": "\"base.Equals\" should not be used to check for reference equality in \"Equals\" if \"base\" is not \"object\""
              },
              "fullDescription": {
                "text": "object.Equals() overrides can be optimized by checking first for reference equality between this and the parameter. This check can be implemented by calling object.ReferenceEquals() or base.Equals(), where base is object. However, using base.Equals() is a maintenance hazard because while it works if you extend Object directly, if you introduce a new base class that overrides Equals, it suddenly stops working."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3397",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3398",
              "shortDescription": {
                "text": "\"private\" methods called only by inner classes should be moved to those classes"
              },
              "fullDescription": {
                "text": "When a private static method is only invoked by a nested class, there’s no reason not to move it into that class. It will still have the same access to the outer class' static members, but the outer class will be clearer and less cluttered."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3398",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3400",
              "shortDescription": {
                "text": "Methods should not return constants"
              },
              "fullDescription": {
                "text": "There’s no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a method call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3400",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.024",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3415",
              "shortDescription": {
                "text": "Assertion arguments should be passed in the correct order"
              },
              "fullDescription": {
                "text": "The standard assertions library methods such as AreEqual and AreSame in MSTest and NUnit, or Equal and Same in XUnit, expect the first argument to be the expected value and the second argument to be the actual value."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3415",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3416",
              "shortDescription": {
                "text": "Loggers should be named for their enclosing types"
              },
              "fullDescription": {
                "text": "It is a well-established convention to name each logger after its enclosing type. This rule raises an issue when the convention is not respected."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3416",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3427",
              "shortDescription": {
                "text": "Method overloads with default parameter values should not overlap"
              },
              "fullDescription": {
                "text": "The rules for method resolution can be complex and may not be fully understood by all developers. The situation becomes even more challenging when dealing with method overloads that have optional parameter values."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3427",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3431",
              "shortDescription": {
                "text": "\"[ExpectedException]\" should not be used"
              },
              "fullDescription": {
                "text": "It should be clear to a casual reader what code a test is testing and what results are expected. Unfortunately, that’s not usually the case with the ExpectedException attribute since an exception could be thrown from almost any line in the method."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3431",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3433",
              "shortDescription": {
                "text": "Test method signatures should be correct"
              },
              "fullDescription": {
                "text": "A method is identified as a test method if it is marked with one of the following attributes:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3433",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3440",
              "shortDescription": {
                "text": "Variables should not be checked against the values they're about to be assigned"
              },
              "fullDescription": {
                "text": "There’s no point in checking a variable against the value you’re about to assign it. Save the cycles and lines of code, and simply perform the assignment."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3440",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3441",
              "shortDescription": {
                "text": "Redundant property names should be omitted in anonymous classes"
              },
              "fullDescription": {
                "text": "When an anonymous type’s properties are copied from properties or variables with the same names, it yields cleaner code to omit the new type’s property name and the assignment operator."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3441",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3442",
              "shortDescription": {
                "text": "\"abstract\" classes should not have \"public\" constructors"
              },
              "fullDescription": {
                "text": "The abstract modifier in a class declaration is used to indicate that a class is intended only to be a base class of other classes, not instantiated on its own."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3442",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.022",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3443",
              "shortDescription": {
                "text": "Type should not be examined on \"System.Type\" instances"
              },
              "fullDescription": {
                "text": "Calling GetType on a Type variable will always return the System.Type representation, which is equivalent to typeof(System.Type). This also applies to passing a Type argument to IsInstanceOfType which always returns false."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3443",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3444",
              "shortDescription": {
                "text": "Interfaces should not simply inherit from base interfaces with colliding members"
              },
              "fullDescription": {
                "text": "When an interface inherits from two interfaces that both define a member with the same name, trying to access that member through the derived interface will result in the compiler error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3444",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3445",
              "shortDescription": {
                "text": "Exceptions should not be explicitly rethrown"
              },
              "fullDescription": {
                "text": "In C#, the throw statement can be used in two different ways:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3445",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3447",
              "shortDescription": {
                "text": "\"[Optional]\" should not be used on \"ref\" or \"out\" parameters"
              },
              "fullDescription": {
                "text": "The use of ref or out in combination with Optional attribute is both confusing and contradictory. [Optional] indicates that the parameter doesn’t have to be provided, while out and ref mean that the parameter will be used to return data to the caller (ref additionally indicates that the parameter may also be used to pass data into the method)."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3447",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3449",
              "shortDescription": {
                "text": "Right operands of shift operators should be integers"
              },
              "fullDescription": {
                "text": "Numbers can be shifted with the << and >> operators, but the right operand of the operation needs to be an int or a type that has an implicit conversion to int. However, when the left operand is dynamic, the compiler’s type checking is turned off, so you can pass anything to the right of a shift operator and have it compile. And if the argument can’t be implicitly converted to int at runtime, then a RuntimeBinderException will be raised."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3449",
              "properties": {
                "category": "Critical Bug",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3450",
              "shortDescription": {
                "text": "Parameters with \"[DefaultParameterValue]\" attributes should also be marked \"[Optional]\""
              },
              "fullDescription": {
                "text": "There is no point in providing a default value for a parameter if callers are required to provide a value for it anyway. Thus, [DefaultParameterValue] should always be used in conjunction with [Optional]."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3450",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3451",
              "shortDescription": {
                "text": "\"[DefaultValue]\" should not be used when \"[DefaultParameterValue]\" is meant"
              },
              "fullDescription": {
                "text": "DefaultValue does not make the compiler set the default value, as its name may suggest. What you probably wanted to use is DefaultParameterValue."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3451",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3453",
              "shortDescription": {
                "text": "Classes should not have only \"private\" constructors"
              },
              "fullDescription": {
                "text": "When a class has only a private constructor, it can’t be instantiated except within the class itself. Such classes can be considered dead code and should be fixed"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3453",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3456",
              "shortDescription": {
                "text": "\"string.ToCharArray()\" and \"ReadOnlySpan<T>.ToArray()\" should not be called redundantly"
              },
              "fullDescription": {
                "text": "The string type offers an indexer property that allows you to treat it as a char array. Therefore, if you just need to access a specific character or iterate over all of them, the ToCharArray call should be omitted. For these cases, not omitting makes the code harder to read and less efficient as ToCharArray copies the characters from the string object into a new Unicode character array."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3456",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3457",
              "shortDescription": {
                "text": "Composite format strings should be used correctly"
              },
              "fullDescription": {
                "text": "A [composite format string](https://learn.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting) is a string that contains placeholders, represented by indices inside curly braces \"{0}\", \"{1}\", etc. These placeholders are replaced by values when the string is printed or logged."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3457",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.028",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3458",
              "shortDescription": {
                "text": "Empty \"case\" clauses that fall through to the \"default\" should be omitted"
              },
              "fullDescription": {
                "text": "Empty case clauses that fall through to the default are useless. Whether or not such a case is present, the default clause will be invoked. Such cases simply clutter the code, and should be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3458",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3459",
              "shortDescription": {
                "text": "Unassigned members should be removed"
              },
              "fullDescription": {
                "text": "Fields and auto-properties that are never assigned to hold the default values for their types. They are either pointless code or, more likely, mistakes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3459",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.022",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3464",
              "shortDescription": {
                "text": "Type inheritance should not be recursive"
              },
              "fullDescription": {
                "text": "Recursion is a technique used to define a problem in terms of the problem itself, usually in terms of a simpler version of the problem itself."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3464",
              "properties": {
                "category": "Blocker Bug",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3466",
              "shortDescription": {
                "text": "Optional parameters should be passed to \"base\" calls"
              },
              "fullDescription": {
                "text": "When optional parameter values are not passed to base method calls, the value passed in by the caller is ignored. This can cause the function to behave differently than expected, leading to errors and making the code difficult to debug."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3466",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3532",
              "shortDescription": {
                "text": "Empty \"default\" clauses should be removed"
              },
              "fullDescription": {
                "text": "The default clause should take appropriate action. Having an empty default is a waste of keystrokes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3532",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3597",
              "shortDescription": {
                "text": "\"ServiceContract\" and \"OperationContract\" attributes should be used together"
              },
              "fullDescription": {
                "text": "The ServiceContract attribute specifies that a class or interface defines the communication contract of a Windows Communication Foundation (WCF) service. The service operations of this class or interface are defined by OperationContract attributes added to methods. It doesn’t make sense to define a contract without any service operations; thus, in a ServiceContract class or interface at least one method should be annotated with OperationContract. Similarly, WCF only serves OperationContract methods that are defined inside ServiceContract classes or interfaces; thus, this rule also checks that ServiceContract is added to the containing type of OperationContract methods."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3597",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3598",
              "shortDescription": {
                "text": "One-way \"OperationContract\" methods should have \"void\" return type"
              },
              "fullDescription": {
                "text": "When declaring a Windows Communication Foundation (WCF) OperationContract method as one-way, that service method won’t return any result, not even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Therefore, specifying a return type has no effect and can confuse readers."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3598",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3600",
              "shortDescription": {
                "text": "\"params\" should not be introduced on overrides"
              },
              "fullDescription": {
                "text": "Adding params to a method override has no effect. The compiler accepts it, but the callers won’t be able to benefit from the added modifier."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3600",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3603",
              "shortDescription": {
                "text": "Methods with \"Pure\" attribute should return a value "
              },
              "fullDescription": {
                "text": "Marking a method with the Pure attribute indicates that the method doesn’t make any visible state changes. Therefore, a Pure method should return a result. Otherwise, it indicates a no-operation call."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3603",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3604",
              "shortDescription": {
                "text": "Member initializer values should not be redundant"
              },
              "fullDescription": {
                "text": "Fields, properties and events can be initialized either inline or in the constructor. Initializing them inline and in the constructor at the same time is redundant; the inline initialization will be overridden."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3604",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.024",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3610",
              "shortDescription": {
                "text": "Nullable type comparison should not be redundant"
              },
              "fullDescription": {
                "text": "Calling GetType() on a nullable value type object returns the underlying value type. Therefore, comparing the returned Type object to typeof(Nullable<SomeType>) will either throw an NullReferenceException or the result will always be true or false and can be known at compile time."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3610",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3626",
              "shortDescription": {
                "text": "Jump statements should not be redundant"
              },
              "fullDescription": {
                "text": "Jump statements, such as return, yield break, goto, and continue let you change the default flow of program execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3626",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.202",
                "executionTimeInPercentage": "1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3655",
              "shortDescription": {
                "text": "Empty nullable value should not be accessed"
              },
              "fullDescription": {
                "text": "Nullable value types can hold either a value or null."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3655",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3717",
              "shortDescription": {
                "text": "Track use of \"NotImplementedException\""
              },
              "fullDescription": {
                "text": "NotImplementedException is often used to mark methods which must be implemented for the overall functionality to be complete, but which the developer wants to implement later. That’s as opposed to the NotSupportedException which is thrown by methods which are required by base classes or interfaces, but which are not appropriate to the current class."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3717",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3776",
              "shortDescription": {
                "text": "Cognitive Complexity of methods should not be too high"
              },
              "fullDescription": {
                "text": "This rule raises an issue when the code cognitive complexity of a function is above a certain threshold."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3776",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3869",
              "shortDescription": {
                "text": "\"SafeHandle.DangerousGetHandle\" should not be called"
              },
              "fullDescription": {
                "text": "The SafeHandle.DangerousGetHandle method poses significant risks and should be used carefully. This method carries the inherent danger of potentially returning an invalid handle, which can result in resource leaks and security vulnerabilities. Although it is technically possible to utilize this method without encountering issues, doing so correctly requires a high level of expertise. Therefore, it is recommended to avoid using this method altogether."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3869",
              "properties": {
                "category": "Blocker Bug",
                "executionTimeInSeconds": "0.021",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3871",
              "shortDescription": {
                "text": "Exception types should be \"public\""
              },
              "fullDescription": {
                "text": "The point of having custom exception types is to convey more information than is available in standard types. But custom exception types must be public for that to work."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3871",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3872",
              "shortDescription": {
                "text": "Parameter names should not duplicate the names of their methods"
              },
              "fullDescription": {
                "text": "The name of a method should communicate what it does, and the names of its parameters should indicate how they’re used. If a method and its parameter have the same name it is an indication that one of these rules of thumb has been broken, if not both. Even if by some trick of language that’s not the case, it is still likely to confuse callers and maintainers."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3872",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3874",
              "shortDescription": {
                "text": "\"out\" and \"ref\" parameters should not be used"
              },
              "fullDescription": {
                "text": "Passing a parameter by reference, which is what happens when you use the out or ref parameter modifiers, means that the method will receive a pointer to the argument, rather than the argument itself. If the argument was a value type, the method will be able to change the argument’s values. If it was a reference type, then the method receives a pointer to a pointer, which is usually not what was intended. Even when it is what was intended, this is the sort of thing that’s difficult to get right, and should be used with caution."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3874",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3875",
              "shortDescription": {
                "text": "\"operator==\" should not be overloaded on reference types"
              },
              "fullDescription": {
                "text": "The use of == to compare two objects is expected to do a reference comparison. That is, it is expected to return true if and only if they are the same object instance. Overloading the operator to do anything else will inevitably lead to the introduction of bugs by callers."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3875",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3876",
              "shortDescription": {
                "text": "Strings or integral types should be used for indexers"
              },
              "fullDescription": {
                "text": "Strings and integral types are typically used as indexers. When some other type is required, it typically indicates design problems, and potentially a situation where a method should be used instead."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3876",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3877",
              "shortDescription": {
                "text": "Exceptions should not be thrown from unexpected methods"
              },
              "fullDescription": {
                "text": "The rule is reporting when an exception is thrown from certain methods and constructors. These methods are expected to behave in a specific way and throwing an exception from them can lead to unexpected behavior and break the calling code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3877",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3878",
              "shortDescription": {
                "text": "Arrays should not be created for params parameters"
              },
              "fullDescription": {
                "text": "There’s no point in creating an array solely for the purpose of passing it to a params parameter. Simply pass the elements directly. They will be consolidated into an array automatically."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3878",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.075",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3880",
              "shortDescription": {
                "text": "Finalizers should not be empty"
              },
              "fullDescription": {
                "text": "Finalizers come with a performance cost due to the overhead of tracking the life cycle of objects. An empty one is consequently costly with no benefit or justification."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3880",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3881",
              "shortDescription": {
                "text": "\"IDisposable\" should be implemented correctly"
              },
              "fullDescription": {
                "text": "The IDisposable interface is a mechanism to release unmanaged resources, if not implemented correctly this could result in resource leaks or more severe bugs."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3881",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3884",
              "shortDescription": {
                "text": "\"CoSetProxyBlanket\" and \"CoInitializeSecurity\" should not be used"
              },
              "fullDescription": {
                "text": "This rule is deprecated, and will eventually be removed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3884",
              "properties": {
                "category": "Blocker Vulnerability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3885",
              "shortDescription": {
                "text": "\"Assembly.Load\" should be used"
              },
              "fullDescription": {
                "text": "The parameter to Assembly.Load includes the full specification of the dll to be loaded. Use another method, and you might end up with a dll other than the one you expected."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3885",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3887",
              "shortDescription": {
                "text": "Mutable, non-private fields should not be \"readonly\""
              },
              "fullDescription": {
                "text": "Using the readonly keyword on a field means it can’t be changed after initialization. However, that’s only partly true when applied to collections or arrays. The readonly keyword enforces that another instance can’t be assigned to the field, but it cannot keep the contents from being updated. In practice, the field value can be changed, and the use of readonly on such a field is misleading, and you’re likely not getting the behavior you expect."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3887",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "0.039",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3889",
              "shortDescription": {
                "text": "\"Thread.Resume\" and \"Thread.Suspend\" should not be used"
              },
              "fullDescription": {
                "text": "Thread.Suspend and Thread.Resume can give unpredictable results, and both methods have been deprecated. Indeed, if Thread.Suspend is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3889",
              "properties": {
                "category": "Blocker Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3897",
              "shortDescription": {
                "text": "Classes that provide \"Equals(<T>)\" should implement \"IEquatable<T>\""
              },
              "fullDescription": {
                "text": "The IEquatable<T> interface has only one method in it: Equals(<T>). If you’ve already written Equals(T), there’s no reason not to explicitly implement IEquatable<T>. Doing so expands the utility of your class by allowing it to be used where an IEquatable is called for."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3897",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3898",
              "shortDescription": {
                "text": "Value types should implement \"IEquatable<T>\""
              },
              "fullDescription": {
                "text": "If you’re using a struct, it is likely because you’re interested in performance. But by failing to implement IEquatable<T> you’re loosing performance when comparisons are made because without IEquatable<T>, boxing and reflection are used to make comparisons."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3898",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3900",
              "shortDescription": {
                "text": "Arguments of public methods should be validated against null"
              },
              "fullDescription": {
                "text": "Methods declared as public, protected, or protected internal can be accessed from other assemblies, which means you should validate parameters to be within the expected constraints. In general, checking against null is recommended in defensive programming."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3900",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3902",
              "shortDescription": {
                "text": "\"Assembly.GetExecutingAssembly\" should not be called"
              },
              "fullDescription": {
                "text": "Using Type.Assembly to get the current assembly is nearly free in terms of performance; it’s a simple property access. On the other hand, Assembly.GetExecutingAssembly() can take up to 30 times as long because it walks up the call stack to find the assembly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3902",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3903",
              "shortDescription": {
                "text": "Types should be defined in named namespaces"
              },
              "fullDescription": {
                "text": "Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are defined outside any named namespace are in a global namespace that cannot be referenced in code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3903",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3904",
              "shortDescription": {
                "text": "Assemblies should have version information"
              },
              "fullDescription": {
                "text": "The AssemblyVersion attribute is used to specify the version number of an assembly. An assembly is a compiled unit of code, which can be marked with a version number by applying the attribute to an assembly’s source code file."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3904",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3906",
              "shortDescription": {
                "text": "Event Handlers should have the correct signature"
              },
              "fullDescription": {
                "text": "Delegate event handlers (i.e. delegates used as type of an event) should have a very specific signature:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3906",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3908",
              "shortDescription": {
                "text": "Generic event handlers should be used"
              },
              "fullDescription": {
                "text": "Since .Net Framework version 2.0 it is not necessary to declare a delegate that specifies a class derived from System.EventArgs. The System.EventHandler<TEventArgs> delegate mechanism should be used instead as it allows any class derived from EventArgs to be used with that handler."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3908",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3909",
              "shortDescription": {
                "text": "Collections should implement the generic interface"
              },
              "fullDescription": {
                "text": "The NET Framework 2.0 introduced the generic interface System.Collections.Generic.IEnumerable<T> and it should be preferred over the older, non generic, interfaces."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3909",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3923",
              "shortDescription": {
                "text": "All branches in a conditional structure should not have exactly the same implementation"
              },
              "fullDescription": {
                "text": "Having all branches of a switch or if chain with the same implementation indicates a problem."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3923",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3925",
              "shortDescription": {
                "text": "\"ISerializable\" should be implemented correctly"
              },
              "fullDescription": {
                "text": "The ISerializable interface is the mechanism to control the type serialization process. If not implemented correctly this could result in an invalid serialization and hard-to-detect bugs."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3925",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3926",
              "shortDescription": {
                "text": "Deserialization methods should be provided for \"OptionalField\" members"
              },
              "fullDescription": {
                "text": "Fields marked with System.Runtime.Serialization.OptionalFieldAttribute are serialized just like any other field. But such fields are ignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to set such fields during the deserialization process."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3926",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3927",
              "shortDescription": {
                "text": "Serialization event handlers should be implemented correctly"
              },
              "fullDescription": {
                "text": "Serialization event handlers that don’t have the correct signature will not be called, bypassing augmentations to automated serialization and deserialization events."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3927",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3928",
              "shortDescription": {
                "text": "Parameter names used into ArgumentException constructors should match an existing one "
              },
              "fullDescription": {
                "text": "Some constructors of the ArgumentException, ArgumentNullException, ArgumentOutOfRangeException and DuplicateWaitObjectException classes must be fed with a valid parameter name. This rule raises an issue in two cases:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3928",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3937",
              "shortDescription": {
                "text": "Number patterns should be regular"
              },
              "fullDescription": {
                "text": "The use of punctuation characters to separate subgroups in a number can make the number more readable. For instance consider 1,000,000,000 versus 1000000000. But when the grouping is irregular, such as 1,000,00,000; it indicates an error."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3937",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3949",
              "shortDescription": {
                "text": "Calculations should not overflow"
              },
              "fullDescription": {
                "text": "Numbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers beyond those bounds, and the result will be a value that has silently wrapped around from the expected positive value to a negative one, or vice versa."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3949",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3956",
              "shortDescription": {
                "text": "\"Generic.List\" instances should not be part of public APIs"
              },
              "fullDescription": {
                "text": "System.Collections.Generic.List<T> is a generic collection that is designed for performance and not inheritance. For example, it does not contain virtual members that make it easier to change the behavior of an inherited class. That means that future attempts to expand the behavior will be spoiled because the extension points simply aren’t there. Instead, one of the following generic collections should be used:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3956",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S3962",
              "shortDescription": {
                "text": "\"static readonly\" constants should be \"const\" instead"
              },
              "fullDescription": {
                "text": "The value of a static readonly field is computed at runtime while the value of a const field is calculated at compile time, which improves performance."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3962",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3963",
              "shortDescription": {
                "text": "\"static\" fields should be initialized inline"
              },
              "fullDescription": {
                "text": "When a static constructor serves no other purpose that initializing static fields, it comes with an unnecessary performance cost because the compiler generates a check before each static method or instance constructor invocation."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3963",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3966",
              "shortDescription": {
                "text": "Objects should not be disposed more than once"
              },
              "fullDescription": {
                "text": "Disposing an object twice in the same method, either with the using keyword or by calling Dispose directly, is confusing and error-prone. For example, another developer might try to use an already-disposed object, or there can be runtime errors for specific paths in the code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3966",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3967",
              "shortDescription": {
                "text": "Multidimensional arrays should not be used"
              },
              "fullDescription": {
                "text": "A jagged array is an array whose elements are arrays. It is recommended over a multidimensional array because the arrays that make up the elements can be of different sizes, which avoids wasting memory space."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3967",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3971",
              "shortDescription": {
                "text": "\"GC.SuppressFinalize\" should not be called"
              },
              "fullDescription": {
                "text": "GC.SuppressFinalize requests that the system not call the finalizer for the specified object. This should only be done when implementing Dispose as part of the Dispose Pattern."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3971",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3972",
              "shortDescription": {
                "text": "Conditionals should start on new lines"
              },
              "fullDescription": {
                "text": "Placing an if statement on the same line as the closing } from a preceding if, else, or else if block can lead to confusion and potential errors. It may indicate a missing else statement or create ambiguity for maintainers who might fail to understand that the two statements are unconnected."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3972",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3973",
              "shortDescription": {
                "text": "A conditionally executed single line should be denoted by indentation"
              },
              "fullDescription": {
                "text": "When the line immediately after conditional statements has neither curly braces nor indentation, the intent of the code is unclear and perhaps not executed as expected. Additionally, such code is confusing to maintainers."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3973",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3981",
              "shortDescription": {
                "text": "Collection sizes and array length comparisons should make sense"
              },
              "fullDescription": {
                "text": "The size of a collection and the length of an array are always greater than or equal to zero. Testing it doesn’t make sense, since the result is always true."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3981",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3984",
              "shortDescription": {
                "text": "Exceptions should not be created without being thrown"
              },
              "fullDescription": {
                "text": "Creating a new Exception without actually throwing does not achieve the intended purpose."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3984",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S3990",
              "shortDescription": {
                "text": "Assemblies should be marked as CLS compliant"
              },
              "fullDescription": {
                "text": "Assemblies should conform with the Common Language Specification (CLS) in order to be usable across programming languages. To be compliant an assembly has to indicate it with System.CLSCompliantAttribute."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3990",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3992",
              "shortDescription": {
                "text": "Assemblies should explicitly specify COM visibility"
              },
              "fullDescription": {
                "text": "Assemblies should explicitly indicate whether they are meant to be COM visible or not. If the ComVisibleAttribute is not present, the default is to make the content of the assembly visible to COM clients."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3992",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3993",
              "shortDescription": {
                "text": "Custom attributes should be marked with \"System.AttributeUsageAttribute\""
              },
              "fullDescription": {
                "text": "When defining custom attributes, System.AttributeUsageAttribute must be used to indicate where the attribute can be applied. This will determine its valid locations in the code."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3993",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3994",
              "shortDescription": {
                "text": "URI Parameters should not be strings"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred. At minimum, an overload of the method taking a System.Uri as a parameter should be provided in each class that contains a method with an apparent Uri passed as a string."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3994",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3995",
              "shortDescription": {
                "text": "URI return values should not be strings"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3995",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3996",
              "shortDescription": {
                "text": "URI properties should not be strings"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3996",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3997",
              "shortDescription": {
                "text": "String URI overloads should call \"System.Uri\" overloads"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3997",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S3998",
              "shortDescription": {
                "text": "Threads should not lock on objects with weak identity"
              },
              "fullDescription": {
                "text": "Objects that can be accessed across application domain boundaries are said to have weak identity. This means that these objects can be considered shared resources outside of the domain, which can be lead to them being accessed or modified by multiple threads or concurrent parts of a program, outside of the domain."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-3998",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4000",
              "shortDescription": {
                "text": "Pointers to unmanaged memory should not be visible"
              },
              "fullDescription": {
                "text": "Pointer and unmanaged function pointer types such as IntPtr, UIntPtr, int* etc. are used to access unmanaged memory, usually in order to use C or C++ libraries. If such a pointer is not secured by making it private, internal or readonly, it can lead to a vulnerability allowing access to arbitrary locations."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4000",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4002",
              "shortDescription": {
                "text": "Disposable types should declare finalizers"
              },
              "fullDescription": {
                "text": "This rule raises an issue when a disposable type contains fields of the following types and does not implement a finalizer:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4002",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4004",
              "shortDescription": {
                "text": "Collection properties should be readonly"
              },
              "fullDescription": {
                "text": "A writable collection property can be replaced by a completely different collection. Making it readonly prevents that while still allowing individual members to be set. If you want to allow the replacement of the whole collection the recommended pattern is to implement a method to remove all the elements (e.g. System.Collections.List<T>.Clear) and a method to populate the collection (e.g. System.Collections.List<T>.AddRange)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4004",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4005",
              "shortDescription": {
                "text": "\"System.Uri\" arguments should be used instead of strings"
              },
              "fullDescription": {
                "text": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4005",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4015",
              "shortDescription": {
                "text": "Inherited member visibility should not be decreased"
              },
              "fullDescription": {
                "text": "Decreasing the accessibility level of an inherited method that is not overridable to private will shadow the name of the base method and can lead to confusion."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4015",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.017",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4016",
              "shortDescription": {
                "text": "Enumeration members should not be named \"Reserved\""
              },
              "fullDescription": {
                "text": "If an enum member’s name contains the word \"reserved\" it implies it is not currently used and will be change in the future. However changing an enum member is a breaking change and can create significant problems. There is no need to reserve an enum member since a new member can be added in the future, and such an addition will usually not be a breaking change."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4016",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4017",
              "shortDescription": {
                "text": "Method signatures should not contain nested generic types"
              },
              "fullDescription": {
                "text": "A nested type is a type argument that is also a generic type. Calling a method with such a nested type argument requires complicated and confusing code. It should be avoided as much as possible."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4017",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4018",
              "shortDescription": {
                "text": "All type parameters should be used in the parameter list to enable type inference"
              },
              "fullDescription": {
                "text": "Type inference enables the call of a generic method without explicitly specifying its type arguments. This is not possible when a parameter type is missing from the argument list."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4018",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4019",
              "shortDescription": {
                "text": "Base class methods should not be hidden"
              },
              "fullDescription": {
                "text": "When a method in a derived class has:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4019",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4022",
              "shortDescription": {
                "text": "Enumerations should have \"Int32\" storage"
              },
              "fullDescription": {
                "text": "By default the storage type of an enum is Int32. In most cases it is not necessary to change this. In particular you will not achieve any performance gain by using a smaller data type (e.g. Byte) and may limit future uses."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4022",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4023",
              "shortDescription": {
                "text": "Interfaces should not be empty"
              },
              "fullDescription": {
                "text": "Empty interfaces should be avoided as they do not provide any functional requirements for implementing classes."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4023",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4025",
              "shortDescription": {
                "text": "Child class fields should not differ from parent class fields only by capitalization"
              },
              "fullDescription": {
                "text": "Having a field in a child class with a name that differs from a parent class' field only by capitalization is sure to cause confusion. Such child class fields should be renamed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4025",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4026",
              "shortDescription": {
                "text": "Assemblies should be marked with \"NeutralResourcesLanguageAttribute\""
              },
              "fullDescription": {
                "text": "It is important to inform the ResourceManager of the language used to display the resources of the neutral culture for an assembly. This improves lookup performance for the first resource loaded."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4026",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4027",
              "shortDescription": {
                "text": "Exceptions should provide standard constructors"
              },
              "fullDescription": {
                "text": "Exceptions types should provide the following constructors:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4027",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4035",
              "shortDescription": {
                "text": "Classes implementing \"IEquatable<T>\" should be sealed"
              },
              "fullDescription": {
                "text": "When a class implements the IEquatable<T> interface, it enters a contract that, in effect, states \"I know how to compare two instances of type T or any type derived from T for equality.\". However if that class is derived, it is very unlikely that the base class will know how to make a meaningful comparison. Therefore that implicit contract is now broken."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4035",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4036",
              "shortDescription": {
                "text": "Searching OS commands in PATH is security-sensitive"
              },
              "fullDescription": {
                "text": "When executing an OS command and unless you specify the full path to the executable, then the locations in your application’s PATH environment variable will be searched for the executable. That search could leave an opening for an attacker if one of the elements in PATH is a directory under his control."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4036",
              "properties": {
                "category": "Minor Security Hotspot",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4039",
              "shortDescription": {
                "text": "Interface methods should be callable by derived types"
              },
              "fullDescription": {
                "text": "When a base type explicitly implements a public interface method, that method is only accessible in derived types through a reference to the current instance (namely this). If the derived type explicitly overrides that interface method, the base implementation becomes inaccessible."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4039",
              "properties": {
                "category": "Critical Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4040",
              "shortDescription": {
                "text": "Strings should be normalized to uppercase"
              },
              "fullDescription": {
                "text": "Certain characters, once normalized to lowercase, cannot make a round trip. That is, they can not be converted from one locale to another and then accurately restored to their original characters."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4040",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4041",
              "shortDescription": {
                "text": "Type names should not match namespaces"
              },
              "fullDescription": {
                "text": "When a type name matches the name of a publicly defined namespace, for instance one in the .NET framework class library, it leads to confusion and makes the library that much harder to use."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4041",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4047",
              "shortDescription": {
                "text": "Generics should be used when appropriate"
              },
              "fullDescription": {
                "text": "When a reference parameter (keyword ref) is used, the passed argument type must exactly match the reference parameter type. This means that to be able to pass a derived type, it must be cast and assigned to a variable of the proper type. Use of generic methods eliminates that cumbersome down casting and should therefore be preferred."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4047",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4049",
              "shortDescription": {
                "text": "Properties should be preferred"
              },
              "fullDescription": {
                "text": "Properties are accessed like fields which makes them easier to use."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4049",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4050",
              "shortDescription": {
                "text": "Operators should be overloaded consistently"
              },
              "fullDescription": {
                "text": "When implementing operator overloads, it is very important to make sure that all related operators and methods are consistent in their implementation."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4050",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4052",
              "shortDescription": {
                "text": "Types should not extend outdated base types"
              },
              "fullDescription": {
                "text": "With the advent of .NET framework version 2, certain practices have become obsolete."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4052",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4055",
              "shortDescription": {
                "text": "Literals should not be passed as localized parameters"
              },
              "fullDescription": {
                "text": "String literals embedded in the source code will not be localized properly."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4055",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4056",
              "shortDescription": {
                "text": "Overloads with a \"CultureInfo\" or an \"IFormatProvider\" parameter should be used"
              },
              "fullDescription": {
                "text": "When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4056",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4057",
              "shortDescription": {
                "text": "Locales should be set for data types"
              },
              "fullDescription": {
                "text": "When you create a DataTable or DataSet, you should set the locale explicitly. By default, the locale for these types is the current culture. For data that is stored in a database or file and is shared globally, the locale should ordinarily be set to the invariant culture (CultureInfo.InvariantCulture)."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4057",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4058",
              "shortDescription": {
                "text": "Overloads with a \"StringComparison\" parameter should be used"
              },
              "fullDescription": {
                "text": "Many string operations, the Compare and Equals methods in particular, provide an overload that accepts a StringComparison enumeration value as a parameter. Calling these overloads and explicitly providing this parameter makes your code clearer and easier to maintain."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4058",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4059",
              "shortDescription": {
                "text": "Property names should not match get methods"
              },
              "fullDescription": {
                "text": "Properties and Get method should have names that makes them clearly distinguishable."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4059",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4060",
              "shortDescription": {
                "text": "Non-abstract attributes should be sealed"
              },
              "fullDescription": {
                "text": "The .NET framework class library provides methods for retrieving custom attributes. Sealing the attribute eliminates the search through the inheritance hierarchy, and can improve performance."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4060",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4061",
              "shortDescription": {
                "text": "\"params\" should be used instead of \"varargs\""
              },
              "fullDescription": {
                "text": "A method using the VarArgs calling convention is not Common Language Specification (CLS) compliant and might not be accessible across programming languages, while the params keyword works the same way and is CLS compliant."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4061",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4069",
              "shortDescription": {
                "text": "Operator overloads should have named alternatives"
              },
              "fullDescription": {
                "text": "Operator overloading is convenient but unfortunately not portable across languages. To be able to access the same functionality from another language you need to provide an alternate named method following the convention:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4069",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4070",
              "shortDescription": {
                "text": "Non-flags enums should not be marked with \"FlagsAttribute\""
              },
              "fullDescription": {
                "text": "This rule raises an issue when an externally visible enumeration is marked with FlagsAttribute and one, or more, of its values is not a power of 2 or a combination of the other defined values."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4070",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4136",
              "shortDescription": {
                "text": "Method overloads should be grouped together"
              },
              "fullDescription": {
                "text": "For clarity, all overloads of the same method should be grouped together. That lets both users and maintainers quickly understand all the current available options."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4136",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.026",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4143",
              "shortDescription": {
                "text": "Collection elements should not be replaced unconditionally"
              },
              "fullDescription": {
                "text": "Storing a value inside a collection at a given key or index and then unconditionally overwriting it without reading the initial value is a case of a \"dead store\"."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4143",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.021",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4144",
              "shortDescription": {
                "text": "Methods should not have identical implementations"
              },
              "fullDescription": {
                "text": "Two methods having the same implementation are suspicious. It might be that something else was intended. Or the duplication is intentional, which becomes a maintenance burden."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4144",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.074",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4158",
              "shortDescription": {
                "text": "Empty collections should not be accessed or iterated"
              },
              "fullDescription": {
                "text": "When a collection is empty, iterating it has no effect. Doing so anyway is likely a bug; either population was accidentally omitted, or the iteration needs to be revised."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4158",
              "properties": {
                "category": "Minor Bug",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4159",
              "shortDescription": {
                "text": "Classes should implement their \"ExportAttribute\" interfaces"
              },
              "fullDescription": {
                "text": "The Attributed Programming Model, also known as Attribute-oriented programming (@OP), is a programming model used to embed attributes within codes."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4159",
              "properties": {
                "category": "Blocker Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4200",
              "shortDescription": {
                "text": "Native methods should be wrapped"
              },
              "fullDescription": {
                "text": "Native methods are functions that reside in libraries outside the .NET runtime. Calling them is helpful for interoperability with applications and libraries written in other programming languages, mainly when performing platform-specific operations. However, doing so comes with additional risks since it means stepping out of the memory-safety model of the runtime. It is therefore highly recommended to take extra steps, like input validation, when invoking native methods. Making the native method private and providing a wrapper that performs these additional steps is the best way to do so."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4200",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.025",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4201",
              "shortDescription": {
                "text": "Null checks should not be combined with \"is\" operator checks"
              },
              "fullDescription": {
                "text": "There’s no need to null test in conjunction with an is test. null is not an instance of anything, so a null check is redundant."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4201",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4210",
              "shortDescription": {
                "text": "Windows Forms entry points should be marked with STAThread"
              },
              "fullDescription": {
                "text": "When an assembly uses Windows Forms (classes and interfaces from the System.Windows.Forms namespace) its entry point should be marked with the STAThreadAttribute to indicate that the threading model should be \"Single-Threaded Apartment\" (STA) which is the only one supported by Windows Forms."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4210",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4211",
              "shortDescription": {
                "text": "Members should not have conflicting transparency annotations"
              },
              "fullDescription": {
                "text": "Transparency attributes in the .NET Framework, designed to protect security-critical operations, can lead to ambiguities and vulnerabilities when declared at different levels such as both for the class and a method."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4211",
              "properties": {
                "category": "Major Vulnerability",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4212",
              "shortDescription": {
                "text": "Serialization constructors should be secured"
              },
              "fullDescription": {
                "text": "This rule is deprecated, and will eventually be removed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4212",
              "properties": {
                "category": "Major Vulnerability",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4214",
              "shortDescription": {
                "text": "\"P/Invoke\" methods should not be visible"
              },
              "fullDescription": {
                "text": "This rule is deprecated; use {rule:csharpsquid:S4200} instead."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4214",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4220",
              "shortDescription": {
                "text": "Events should have proper arguments"
              },
              "fullDescription": {
                "text": "When raising an event, two arguments are expected by the EventHandler delegate: Sender and event-data. There are three guidelines regarding these parameters:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4220",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.031",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4225",
              "shortDescription": {
                "text": "Extension methods should not extend \"object\""
              },
              "fullDescription": {
                "text": "﻿Creating an extension method that extends object is not recommended because it makes the method available on every type. Extensions should be applied at the most specialized level possible, and that is very unlikely to be object."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4225",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4226",
              "shortDescription": {
                "text": "Extensions should be in separate namespaces"
              },
              "fullDescription": {
                "text": "It makes little sense to create an extension method when it is possible to just add that method to the class itself."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4226",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4260",
              "shortDescription": {
                "text": "\"ConstructorArgument\" parameters should exist in constructors"
              },
              "fullDescription": {
                "text": "When creating a custom Markup Extension that accepts parameters in WPF, the ConstructorArgument markup must be used to identify the discrete properties that match these parameters. However since this is done via a string, the compiler won’t give you any warning in case there are typos."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4260",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4261",
              "shortDescription": {
                "text": "Methods should be named according to their synchronicities"
              },
              "fullDescription": {
                "text": "According to the Task-based Asynchronous Pattern (TAP), methods returning either a System.Threading.Tasks.Task or a System.Threading.Tasks.Task<TResult> are considered \"asynchronous\". Such methods should use the Async suffix. Conversely methods which do not return such Tasks should not have an \"Async\" suffix in their names."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4261",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4275",
              "shortDescription": {
                "text": "Getters and setters should access the expected fields"
              },
              "fullDescription": {
                "text": "Properties provide a way to enforce encapsulation by providing accessors that give controlled access to private fields. However, in classes with multiple fields, it is not unusual that copy-and-paste is used to quickly create the needed properties, which can result in the wrong field being accessed by a getter or setter."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4275",
              "properties": {
                "category": "Critical Bug",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4277",
              "shortDescription": {
                "text": "\"Shared\" parts should not be created with \"new\""
              },
              "fullDescription": {
                "text": "Marking a class with PartCreationPolicy(CreationPolicy.Shared), which is part of Managed Extensibility Framework (MEF), means that a single, shared instance of the exported object will be created. Therefore it doesn’t make sense to create new instances using the constructor and it will most likely result in unexpected behaviours."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4277",
              "properties": {
                "category": "Critical Bug",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4347",
              "shortDescription": {
                "text": "Secure random number generators should not output predictable values"
              },
              "fullDescription": {
                "text": "Cryptographic operations often rely on unpredictable random numbers to enhance security. These random numbers are created by cryptographically secure pseudo-random number generators (CSPRNG). It is important not to use a predictable seed with these random number generators otherwise the random numbers will also become predictable."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4347",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4423",
              "shortDescription": {
                "text": "Weak SSL/TLS protocols should not be used"
              },
              "fullDescription": {
                "text": "This vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4423",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4426",
              "shortDescription": {
                "text": "Cryptographic keys should be robust"
              },
              "fullDescription": {
                "text": "This vulnerability exposes encrypted data to attacks whose goal is to recover the plaintext."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4426",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "0.026",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4428",
              "shortDescription": {
                "text": "\"PartCreationPolicyAttribute\" should be used with \"ExportAttribute\""
              },
              "fullDescription": {
                "text": "To customize the default behavior for an export in the Managed Extensibility Framework (MEF), applying the PartCreationPolicyAttribute is necessary. For the PartCreationPolicyAttribute to be meaningful in the context of an export, the class must also be annotated with the ExportAttribute."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4428",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4433",
              "shortDescription": {
                "text": "LDAP connections should be authenticated"
              },
              "fullDescription": {
                "text": "Lightweight Directory Access Protocol (LDAP) servers provide two main authentication methods: the SASL and Simple ones. The Simple Authentication method also breaks down into three different mechanisms:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4433",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4456",
              "shortDescription": {
                "text": "Parameter validation in yielding methods should be wrapped"
              },
              "fullDescription": {
                "text": "Because of the way yield methods are rewritten by the compiler (they become lazily evaluated state machines) any exceptions thrown during the parameters check will happen only when the collection is iterated over. That could happen far away from the source of the buggy code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4456",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4457",
              "shortDescription": {
                "text": "Parameter validation in \"async\"/\"await\" methods should be wrapped"
              },
              "fullDescription": {
                "text": "Because of the way async/await methods are rewritten by the compiler, any exceptions thrown during the parameters check will happen only when the task is observed. That could happen far away from the source of the buggy code or never happen for fire-and-forget tasks."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4457",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S4462",
              "shortDescription": {
                "text": "Calls to \"async\" methods should not be blocking"
              },
              "fullDescription": {
                "text": "Making blocking calls to async methods transforms code that was intended to be asynchronous into a blocking operation. Doing so can cause deadlocks and unexpected blocking of context threads."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4462",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4487",
              "shortDescription": {
                "text": "Unread \"private\" fields should be removed"
              },
              "fullDescription": {
                "text": "Private fields which are written but never read are a case of \"dead store\". Changing the value of such a field is useless and most probably indicates an error in the code."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4487",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.156",
                "executionTimeInPercentage": "1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4502",
              "shortDescription": {
                "text": "Disabling CSRF protections is security-sensitive"
              },
              "fullDescription": {
                "text": "A cross-site request forgery (CSRF) attack occurs when a trusted user of a web application can be forced, by an attacker, to perform sensitive actions that he didn’t intend, such as updating his profile or sending a message, more generally anything that can change the state of the application."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4502",
              "properties": {
                "category": "Critical Security Hotspot",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4507",
              "shortDescription": {
                "text": "Delivering code in production with debug features activated is security-sensitive"
              },
              "fullDescription": {
                "text": "Development tools and frameworks usually have options to make debugging easier for developers. Although these features are useful during development, they should never be enabled for applications deployed in production. Debug instructions or error messages can leak detailed information about the system, like the application’s path or file names."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4507",
              "properties": {
                "category": "Minor Security Hotspot",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4524",
              "shortDescription": {
                "text": "\"default\" clauses should be first or last"
              },
              "fullDescription": {
                "text": "The switch statement is a conditional statement that executes a sequence of instructions based on patterns matching the provided value."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4524",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4545",
              "shortDescription": {
                "text": "\"DebuggerDisplayAttribute\" strings should reference existing members"
              },
              "fullDescription": {
                "text": "The DebuggerDisplayAttribute is used to determine how an object is displayed in the debugger window."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4545",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4581",
              "shortDescription": {
                "text": "\"new Guid()\" should not be used"
              },
              "fullDescription": {
                "text": "When the syntax new Guid() (i.e. parameterless instantiation) is used, it must be that one of three things is wanted:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4581",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4583",
              "shortDescription": {
                "text": "Calls to delegate's method \"BeginInvoke\" should be paired with calls to \"EndInvoke\""
              },
              "fullDescription": {
                "text": "When calling the BeginInvoke method of a delegate, resources are allocated that are only freed up when EndInvoke is called. Failing to pair BeginInvoke with EndInvoke can lead to resource leaks and incomplete asynchronous calls."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4583",
              "properties": {
                "category": "Critical Bug",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4586",
              "shortDescription": {
                "text": "Non-async \"Task/Task<T>\" methods should not return null"
              },
              "fullDescription": {
                "text": "Returning null from a non-async Task/Task<TResult> method will cause a NullReferenceException at runtime if the method is awaited. This problem can be avoided by returning Task.CompletedTask or Task.FromResult<TResult>(null) respectively."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4586",
              "properties": {
                "category": "Critical Bug",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4635",
              "shortDescription": {
                "text": "Start index should be used instead of calling Substring"
              },
              "fullDescription": {
                "text": "It is important to be careful when searching for characters within a substring. Let’s consider the following example:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4635",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4663",
              "shortDescription": {
                "text": "Comments should not be empty"
              },
              "fullDescription": {
                "text": "Empty comments, as shown in the example, hurt readability and might indicate an oversight."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4663",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4790",
              "shortDescription": {
                "text": "Using weak hashing algorithms is security-sensitive"
              },
              "fullDescription": {
                "text": "Cryptographic hash algorithms such as MD2, MD4, MD5, MD6, HAVAL-128, HMAC-MD5, DSA (which uses SHA-1), RIPEMD, RIPEMD-128, RIPEMD-160, HMACRIPEMD160 and SHA-1 are no longer considered secure, because it is possible to have collisions (little computational effort is enough to find two or more different inputs that produce the same hash)."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4790",
              "properties": {
                "category": "Critical Security Hotspot",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S4792",
              "shortDescription": {
                "text": "Configuring loggers is security-sensitive"
              },
              "fullDescription": {
                "text": "This rule is deprecated, and will eventually be removed."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4792",
              "properties": {
                "category": "Critical Security Hotspot",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S4830",
              "shortDescription": {
                "text": "Server certificates should be verified during SSL/TLS connections"
              },
              "fullDescription": {
                "text": "This vulnerability makes it possible that an encrypted communication is intercepted."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-4830",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5034",
              "shortDescription": {
                "text": "\"ValueTask\" should be consumed correctly"
              },
              "fullDescription": {
                "text": "ValueTask<TResult> provides a value type that wraps a Task<TResult> and the corresponding TResult. It was introduced in .NET Core 2.0 to optimize memory allocation when functions return their results synchronously."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5034",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.038",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5042",
              "shortDescription": {
                "text": "Expanding archive files without controlling resource consumption is security-sensitive"
              },
              "fullDescription": {
                "text": "Successful Zip Bomb attacks occur when an application expands untrusted archive files without controlling the size of the expanded data, which can lead to denial of service. A Zip bomb is usually a malicious archive file of a few kilobytes of compressed data but turned into gigabytes of uncompressed data. To achieve this extreme compression ratio, attackers will compress irrelevant data (eg: a long string of repeated bytes)."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5042",
              "properties": {
                "category": "Critical Security Hotspot",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5122",
              "shortDescription": {
                "text": "Having a permissive Cross-Origin Resource Sharing policy is security-sensitive"
              },
              "fullDescription": {
                "text": "Having a permissive Cross-Origin Resource Sharing policy is security-sensitive. It has led in the past to the following vulnerabilities:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5122",
              "properties": {
                "category": "Minor Security Hotspot",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5332",
              "shortDescription": {
                "text": "Using clear-text protocols is security-sensitive"
              },
              "fullDescription": {
                "text": "Clear-text protocols such as ftp, telnet, or http lack encryption of transported data, as well as the capability to build an authenticated connection. It means that an attacker able to sniff traffic from the network can read, modify, or corrupt the transported content. These protocols are not secure as they expose applications to an extensive range of risks:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5332",
              "properties": {
                "category": "Critical Security Hotspot",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5344",
              "shortDescription": {
                "text": "Passwords should not be stored in plaintext or with a fast hashing algorithm"
              },
              "fullDescription": {
                "text": "The improper storage of passwords poses a significant security risk to software applications. This vulnerability arises when passwords are stored in plaintext or with a fast hashing algorithm. To exploit this vulnerability, an attacker typically requires access to the stored passwords."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5344",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "0.044",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5443",
              "shortDescription": {
                "text": "Using publicly writable directories is security-sensitive"
              },
              "fullDescription": {
                "text": "Operating systems have global directories where any user has write access. Those folders are mostly used as temporary storage areas like /tmp in Linux based systems. An application manipulating files from these folders is exposed to race conditions on filenames: a malicious user can try to create a file with a predictable name before the application does. A successful attack can result in other files being accessed, modified, corrupted or deleted. This risk is even higher if the application runs with elevated permissions."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5443",
              "properties": {
                "category": "Critical Security Hotspot",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5445",
              "shortDescription": {
                "text": "Insecure temporary file creation methods should not be used"
              },
              "fullDescription": {
                "text": "Temporary files are considered insecurely created when the file existence check is performed separately from the actual file creation. Such a situation can occur when creating temporary files using normal file handling functions or when using dedicated temporary file handling functions that are not atomic."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5445",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5542",
              "shortDescription": {
                "text": "Encryption algorithms should be used with secure mode and padding scheme"
              },
              "fullDescription": {
                "text": "This vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5542",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "0.010",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5547",
              "shortDescription": {
                "text": "Cipher algorithms should be robust"
              },
              "fullDescription": {
                "text": "This vulnerability makes it possible that the cleartext of the encrypted message might be recoverable without prior knowledge of the key."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5547",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "0.047",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5659",
              "shortDescription": {
                "text": "JWT should be signed and verified with strong cipher algorithms"
              },
              "fullDescription": {
                "text": "This vulnerability allows forging of JSON Web Tokens to impersonate other users."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5659",
              "properties": {
                "category": "Critical Vulnerability",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5693",
              "shortDescription": {
                "text": "Allowing requests with excessive content length is security-sensitive"
              },
              "fullDescription": {
                "text": "Rejecting requests with significant content length is a good practice to control the network traffic intensity and thus resource consumption in order to prevent DoS attacks."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5693",
              "properties": {
                "category": "Major Security Hotspot",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5753",
              "shortDescription": {
                "text": "Disabling ASP.NET \"Request Validation\" feature is security-sensitive"
              },
              "fullDescription": {
                "text": "ASP.NET 1.1+ comes with a feature called Request Validation, preventing the server to accept content containing un-encoded HTML. This feature comes as a first protection layer against Cross-Site Scripting (XSS) attacks and act as a simple Web Application Firewall (WAF) rejecting requests potentially containing malicious content."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5753",
              "properties": {
                "category": "Major Security Hotspot",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5766",
              "shortDescription": {
                "text": "Deserializing objects without performing data validation is security-sensitive"
              },
              "fullDescription": {
                "text": "Deserialization process extracts data from the serialized representation of an object and reconstruct it directly, without calling constructors. Thus, data validation implemented in constructors can be bypassed if serialized objects are controlled by an attacker."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5766",
              "properties": {
                "category": "Major Security Hotspot",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5773",
              "shortDescription": {
                "text": "Types allowed to be deserialized should be restricted"
              },
              "fullDescription": {
                "text": "Deserialization is the process of converting serialized data (such as objects or data structures) back into their original form. Types allowed to be unserialized should be strictly controlled."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5773",
              "properties": {
                "category": "Major Vulnerability",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S5856",
              "shortDescription": {
                "text": "Regular expressions should be syntactically valid"
              },
              "fullDescription": {
                "text": "Regular expressions have their own syntax that is understood by regular expression engines. Those engines will throw an exception at runtime if they are given a regular expression that does not conform to that syntax."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-5856",
              "properties": {
                "category": "Critical Bug",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6354",
              "shortDescription": {
                "text": "Use a testable date/time provider"
              },
              "fullDescription": {
                "text": "One of the principles of a unit test is that it must have full control of the system under test. This is problematic when production code includes calls to static methods, which cannot be changed or controlled. Date/time functions are usually provided by system libraries as static methods."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6354",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S6377",
              "shortDescription": {
                "text": "XML signatures should be validated securely"
              },
              "fullDescription": {
                "text": "XML signatures are a method used to ensure the integrity and authenticity of XML documents. However, if XML signatures are not validated securely, it can lead to potential vulnerabilities."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6377",
              "properties": {
                "category": "Major Vulnerability",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6419",
              "shortDescription": {
                "text": "Azure Functions should be stateless"
              },
              "fullDescription": {
                "text": "An Azure Function should be stateless as there’s no control over where and when function instances are provisioned and de-provisioned. Managing and storing data/state between requests can lead to inconsistencies. If, for any reason, you need to have a stateful function, consider using the Durable Functions extension of Azure Functions."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6419",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6420",
              "shortDescription": {
                "text": "Client instances should not be recreated on each Azure Function invocation"
              },
              "fullDescription": {
                "text": "To avoid holding more connections than necessary and to avoid potentially exhausting the number of available sockets when using HttpClient, DocumentClient, QueueClient, ConnectionMultiplexer or Azure Storage clients, consider:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6420",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6421",
              "shortDescription": {
                "text": "Azure Functions should use Structured Error Handling"
              },
              "fullDescription": {
                "text": "The top-most level of an Azure Function code should include a try/catch block to capture and log all errors so you can monitor the health of the application effectively. In case a retry policy has been defined for your Azure Function, you should rethrow any errors that should result in a retry."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6421",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S6422",
              "shortDescription": {
                "text": "Calls to \"async\" methods should not be blocking in Azure Functions"
              },
              "fullDescription": {
                "text": "Making blocking calls to async methods transforms the code into a synchronous operation. Doing so inside an Azure Function can lead to thread pool exhaustion."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6422",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6423",
              "shortDescription": {
                "text": "Azure Functions should log all failures"
              },
              "fullDescription": {
                "text": "Capturing and logging errors is critical to monitoring the health of your Azure Functions application."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6423",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S6424",
              "shortDescription": {
                "text": "Interfaces for durable entities should satisfy the restrictions"
              },
              "fullDescription": {
                "text": "The recommended way to access Azure Durable Entities is through generated proxy objects with the help of interfaces."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6424",
              "properties": {
                "category": "Blocker Code Smell",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6444",
              "shortDescription": {
                "text": "Not specifying a timeout for regular expressions is security-sensitive"
              },
              "fullDescription": {
                "text": "Not specifying a timeout for regular expressions can lead to a Denial-of-Service attack. Pass a timeout when using System.Text.RegularExpressions to process untrusted input because a malicious user might craft a value for which the evaluation lasts excessively long."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6444",
              "properties": {
                "category": "Major Security Hotspot",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6507",
              "shortDescription": {
                "text": "Blocks should not be synchronized on local variables"
              },
              "fullDescription": {
                "text": "Locking on a local variable can undermine synchronization because two different threads running the same method in parallel will potentially lock on different instances of the same object, allowing them to access the synchronized block at the same time."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6507",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S6513",
              "shortDescription": {
                "text": "\"ExcludeFromCodeCoverage\" attributes should include a justification"
              },
              "fullDescription": {
                "text": "The ExcludeFromCodeCoverageAttribute is used to exclude portions of code from code coverage reporting. It is a bad practice to retain code that is not covered by unit tests. In .Net 5, the Justification property was added to the ExcludeFromCodeCoverageAttribute as an opportunity to document the rationale for the exclusion. This rule raises an issue when no such justification is given."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6513",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope"
                ]
              }
            },
            {
              "id": "S6561",
              "shortDescription": {
                "text": "Avoid using \"DateTime.Now\" for benchmarking or timing operations"
              },
              "fullDescription": {
                "text": "The rule targets the use of DateTime.Now call followed by some arithmetic operation."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6561",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.023",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6562",
              "shortDescription": {
                "text": "Always set the \"DateTimeKind\" when creating new \"DateTime\" instances"
              },
              "fullDescription": {
                "text": "Not knowing the Kind of the DateTime object that an application is using can lead to misunderstandings when displaying or comparing them. Explicitly setting the Kind property helps the application to stay consistent, and its maintainers understand what kind of date is being managed. To achieve this, when instantiating a new DateTime object you should always use a constructor overload that allows you to define the Kind property."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6562",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6563",
              "shortDescription": {
                "text": "Use UTC when recording DateTime instants"
              },
              "fullDescription": {
                "text": "You should avoid recording time instants with the use of property DateTime.Now. The property DateTime.Now returns the current date and time expressed in the machine’s local time without containing any timezone-related information (for example, the offset from Coordinated Universal Time). Not having this information means that if you need to display this DateTime object or use it for computations in another machine placed in a different time zone, you won’t be able to reconstruct it in the second machine’s local time without knowing the origin’s offset. This will likely lead to confusion and potential bugs."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6563",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S6566",
              "shortDescription": {
                "text": "Use \"DateTimeOffset\" instead of \"DateTime\""
              },
              "fullDescription": {
                "text": "This rule recommends using DateTimeOffset instead of DateTime for projects targeting .NET Framework 2.0 or later."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6566",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S6575",
              "shortDescription": {
                "text": "Use \"TimeZoneInfo.FindSystemTimeZoneById\" without converting the timezones with \"TimezoneConverter\""
              },
              "fullDescription": {
                "text": "Since .NET 6 you don’t have to use the TimeZoneConverter library to manually do the conversion between IANA and Windows timezones. The .NET 6.0 introduced new Time Zone enhancements, one being the TimeZoneInfo.FindSystemTimeZoneById(string timezone) method now accepts as input both IANA and Windows time zone IDs on any operating system with installed time zone data. TimeZoneInfo.FindSystemTimeZoneById will automatically convert its input from IANA to Windows and vice versa if the requested time zone is not found on the system."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6575",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6580",
              "shortDescription": {
                "text": "Use a format provider when parsing date and time"
              },
              "fullDescription": {
                "text": "When converting a string representation of a date and time to a DateTime object or any other temporal type with one of the available system parsing methods, you should always provide an IFormatProvider parameter."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6580",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6585",
              "shortDescription": {
                "text": "Don't hardcode the format when turning dates and times to strings"
              },
              "fullDescription": {
                "text": "Hardcoding the date and time format strings can lead to formats that consumers misunderstand. Also, if the same format is meant to be used in multiple places, it is easier to make a mistake when it’s hardcoded instead of using a format provided by an IFormatProvider or using one of the standard format strings."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6585",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S6588",
              "shortDescription": {
                "text": "Use the \"UnixEpoch\" field instead of creating \"DateTime\" instances that point to the beginning of the Unix epoch"
              },
              "fullDescription": {
                "text": "With .NET Core the UnixEpoch field was introduced to DateTime and DateTimeOffset types. Using this field clearly states that the intention is to use the beginning of the Unix epoch."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6588",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6602",
              "shortDescription": {
                "text": "\"Find\" method should be used instead of the \"FirstOrDefault\" extension"
              },
              "fullDescription": {
                "text": "Both the List.Find method and IEnumerable.FirstOrDefault method can be used to find the first element that satisfies a given condition in a collection. However, List.Find can be faster than IEnumerable.FirstOrDefault for List objects. For small collections, the performance difference may be minor, but for large collections, it can make a noticeable difference. The same applies for ImmutableList and arrays too."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6602",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6603",
              "shortDescription": {
                "text": "The collection-specific \"TrueForAll\" method should be used instead of the \"All\" extension"
              },
              "fullDescription": {
                "text": "Both the List.TrueForAll method and the IEnumerable.All method can be used to check if all list elements satisfy a given condition in a collection. However, List.TrueForAll can be faster than IEnumerable.All for List objects. The performance difference may be minor for small collections, but for large collections, it can be noticeable."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6603",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6605",
              "shortDescription": {
                "text": "Collection-specific \"Exists\" method should be used instead of the \"Any\" extension"
              },
              "fullDescription": {
                "text": "Both the List.Exists method and IEnumerable.Any method can be used to find the first element that satisfies a predicate in a collection. However, List.Exists can be faster than IEnumerable.Any for List objects, as well as requires significantly less memory. For small collections, the performance difference may be negligible, but for large collections, it can be noticeable. The same applies to ImmutableList and arrays too."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6605",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6607",
              "shortDescription": {
                "text": "The collection should be filtered before sorting by using \"Where\" before \"OrderBy\""
              },
              "fullDescription": {
                "text": "When working with LINQ in C#, it is recommended to pay attention to the order in which methods are chained, especially when using Where and OrderBy methods. It is advised to call the Where method before OrderBy because Where filters the elements of the sequence based on a given condition and returns a new sequence containing only the elements that satisfy that condition. Calling OrderBy before Where, may end up sorting elements that will be later discarded, which can lead to inefficiency. Conversely, calling Where before OrderBy, will first filter the sequence to include only the elements of interest, and then sort them based on the specified order."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6607",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6608",
              "shortDescription": {
                "text": "Prefer indexing instead of \"Enumerable\" methods on types implementing \"IList\""
              },
              "fullDescription": {
                "text": "Indexes in C# provide direct access to an element at a specific position within an array or collection. When compared to Enumerable methods, indexing can be more efficient for certain scenarios, such as iterating over a large collection, due to avoiding the overhead of checking the underlying collection type before accessing it."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6608",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6609",
              "shortDescription": {
                "text": "\"Min/Max\" properties of \"Set\" types should be used instead of the \"Enumerable\" extension methods"
              },
              "fullDescription": {
                "text": "Both the Enumerable.Max extension method and the SortedSet<T>.Max property can be used to find the maximum value in a SortedSet<T>. However, SortedSet<T>.Max is much faster than Enumerable.Max. For small collections, the performance difference may be minor, but for large collections, it can be noticeable. The same applies for the Min property as well."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6609",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6610",
              "shortDescription": {
                "text": "\"StartsWith\" and \"EndsWith\" overloads that take a \"char\" should be used instead of the ones that take a \"string\""
              },
              "fullDescription": {
                "text": "With string.StartsWith(char) and string.EndsWith(char), only the first character of the string is compared to the provided character, whereas the string versions of those methods have to do checks about the current StringComparison and CultureInfo. Thus, the char overloads are significantly faster for default comparison scenarios."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6610",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6612",
              "shortDescription": {
                "text": "The lambda parameter should be used instead of capturing arguments in \"ConcurrentDictionary\" methods"
              },
              "fullDescription": {
                "text": "When using the ConcurrentDictionary, there are many overloads of the GetOrAdd and AddOrUpdate methods that take both a TKey argument and a lambda that expects a TKey parameter. This means that the right side of the lambda can be written using either the lambda’s parameter or the method’s argument. However, using the method’s argument leads to the lambda capturing it, and the compiler will need to generate a class and instantiate it before the call. This means memory allocations, as well as more time spend during Garbage Collection."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6612",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6613",
              "shortDescription": {
                "text": "\"First\" and \"Last\" properties of \"LinkedList\" should be used instead of the \"First()\" and \"Last()\" extension methods"
              },
              "fullDescription": {
                "text": "Both the Enumerable.First extension method and the LinkedList<T>.First property can be used to find the first value in a LinkedList<T>. However, LinkedList<T>.First is much faster than Enumerable.First. For small collections, the performance difference may be minor, but for large collections, it can be noticeable. The same applies for the Last property as well."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6613",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6617",
              "shortDescription": {
                "text": "\"Contains\" should be used instead of \"Any\" for simple equality checks"
              },
              "fullDescription": {
                "text": "When testing if a collection contains a specific item by simple equality, both ICollection.Contains(T item) and IEnumerable.Any(x ⇒ x == item) can be used. However, Any searches the data structure in a linear manner using a foreach loop, whereas Contains is considerably faster in some collection types, because of the underlying implementation. More specifically:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6617",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6618",
              "shortDescription": {
                "text": "\"string.Create\" should be used instead of \"FormattableString\""
              },
              "fullDescription": {
                "text": "In order to produce a formatted string, both string.Create and either FormattableString.Invariant or FormattableString.CurrentCulture can be used. However, string.Create rents array buffers from ArrayPool<char> making it more performant, as well as preventing unnecessary allocations and future stress on the Garbage Collector."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6618",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.008",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6640",
              "shortDescription": {
                "text": "Using unsafe code blocks is security-sensitive"
              },
              "fullDescription": {
                "text": "Using unsafe code blocks can lead to unintended security or stability risks."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6640",
              "properties": {
                "category": "Major Security Hotspot",
                "executionTimeInSeconds": "0.020",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6664",
              "shortDescription": {
                "text": "The code block contains too many logging calls"
              },
              "fullDescription": {
                "text": "A code block should not contain too many logging statements of a specific level."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6664",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6667",
              "shortDescription": {
                "text": "Logging in a catch clause should pass the caught exception as a parameter."
              },
              "fullDescription": {
                "text": "This rule raises an issue on logging calls inside a catch clause that does not pass the raised Exception."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6667",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6668",
              "shortDescription": {
                "text": "Logging arguments should be passed to the correct parameter"
              },
              "fullDescription": {
                "text": "Most logging frameworks have methods that take a log level, an event ID or an exception as a separate input next to the log format and its arguments. There is a high chance that if the log level, the event ID or the exception are passed as the arguments to the message format, it was a mistake. This rule is going to raise in that scenario."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6668",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.014",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6669",
              "shortDescription": {
                "text": "Logger field or property name should comply with a naming convention"
              },
              "fullDescription": {
                "text": "Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule checks that the logger field or property name matches a provided regular expression."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6669",
              "properties": {
                "category": "Minor Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6670",
              "shortDescription": {
                "text": "\"Trace.Write\" and \"Trace.WriteLine\" should not be used"
              },
              "fullDescription": {
                "text": "Trace.Write and Trace.WriteLine methods are writing to the underlying output stream directly, bypassing the trace formatting and filtering performed by TraceListener.TraceEvent implementations. It is preferred to use Trace.TraceError, Trace.TraceWarning, and Trace.TraceInformation methods instead because they call the TraceEvent method which filters the trace output according to the TraceEventType (Error, Warning or Information) and enhance the output with additional information."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6670",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6672",
              "shortDescription": {
                "text": "Generic logger injection should match enclosing type"
              },
              "fullDescription": {
                "text": "In most logging frameworks, it’s good practice to set the logger name to match its enclosing type, as enforced by {rule:csharpsquid:S3416}."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6672",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6673",
              "shortDescription": {
                "text": "Log message template placeholders should be in the right order"
              },
              "fullDescription": {
                "text": "The positions of arguments in a logging call should match the positions of their message template placeholders."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6673",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6674",
              "shortDescription": {
                "text": "Log message template should be syntactically correct"
              },
              "fullDescription": {
                "text": "A message template must conform to the specification. The rule raises an issue if the template string violates the template string grammar."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6674",
              "properties": {
                "category": "Critical Bug",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6675",
              "shortDescription": {
                "text": "\"Trace.WriteLineIf\" should not be used with \"TraceSwitch\" levels"
              },
              "fullDescription": {
                "text": "The Trace.WriteLineIf Method from the System.Diagnostic.Trace facility writes a trace if the condition passed as the first parameter is true."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6675",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.012",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6677",
              "shortDescription": {
                "text": "Message template placeholders should be unique"
              },
              "fullDescription": {
                "text": "Named placeholders in message templates should be unique. The meaning of the named placeholders is to store the value of the provided argument under that name, enabling easier log querying. Since the named placeholder is used multiple times, it cannot store the different values uniquely with each name hence not serving its original purpose. There can be different behaviours when using the same named placeholder multiple times:"
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6677",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6678",
              "shortDescription": {
                "text": "Use PascalCase for named placeholders"
              },
              "fullDescription": {
                "text": "Within a message template each named placeholder should be in PascalCase."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6678",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6781",
              "shortDescription": {
                "text": "JWT secret keys should not be disclosed"
              },
              "fullDescription": {
                "text": "Secret leaks often occur when a sensitive piece of authentication data is stored with the source code of an application. Considering the source code is intended to be deployed across multiple assets, including source code repositories or application hosting servers, the secrets might get exposed to an unintended audience."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6781",
              "properties": {
                "category": "Blocker Vulnerability",
                "executionTimeInSeconds": "2.289",
                "executionTimeInPercentage": "15",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6797",
              "shortDescription": {
                "text": "Blazor query parameter type should be supported"
              },
              "fullDescription": {
                "text": "The SupplyParameterFromQuery attribute can be used to specify that a component parameter, of a routable component, comes from the query string."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6797",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6798",
              "shortDescription": {
                "text": "[JSInvokable] attribute should only be used on public methods"
              },
              "fullDescription": {
                "text": "In Blazor, the [JSInvokable] attribute is used to annotate a method, enabling it to be invoked from JavaScript code. The prerequisite for this functionality is that the method must be declared as public. Otherwise, a runtime error will be triggered when an attempt is made to call the method from JavaScript."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6798",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6800",
              "shortDescription": {
                "text": "Component parameter type should match the route parameter type constraint"
              },
              "fullDescription": {
                "text": "In Blazor, when a route parameter constraint is applied, the value is automatically cast to the corresponding component parameter type. If the constraint type does not match the component parameter type, it can lead to confusion and potential runtime errors due to unsuccessful casting. Therefore, it is crucial to ensure that the types of route parameters and component parameters match to prevent such issues and maintain code clarity."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6800",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6802",
              "shortDescription": {
                "text": "Using lambda expressions in loops should be avoided in Blazor markup section"
              },
              "fullDescription": {
                "text": "In Blazor, using lambda expressions as event handlers when the UI elements are rendered in a loop can lead to negative user experiences and performance issues. This is particularly noticeable when rendering a large number of elements."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6802",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S6803",
              "shortDescription": {
                "text": "Parameters with SupplyParameterFromQuery attribute should be used only in routable components"
              },
              "fullDescription": {
                "text": "This rule is deprecated, and will eventually be removed."
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6803",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S6930",
              "shortDescription": {
                "text": "Backslash should be avoided in route templates"
              },
              "fullDescription": {
                "text": "Backslash characters (\\) should be avoided in route templates."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6930",
              "properties": {
                "category": "Major Bug",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6931",
              "shortDescription": {
                "text": "ASP.NET controller actions should not have a route template starting with \"/\""
              },
              "fullDescription": {
                "text": "Route templates for ASP.NET controller actions, defined via a RouteAttribute or any derivation of HttpMethodAttribute, should not start with \"/\"."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6931",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6932",
              "shortDescription": {
                "text": "Use model binding instead of reading raw request data"
              },
              "fullDescription": {
                "text": "The HttpRequest class provides access to the raw request data through the QueryString, Headers, and Forms properties. However, whenever possible it is recommended to use model binding instead of directly accessing the input data."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6932",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6934",
              "shortDescription": {
                "text": "A Route attribute should be added to the controller when a route template is specified at the action level"
              },
              "fullDescription": {
                "text": "When a route template is defined through an attribute on an action method, conventional routing for that action is disabled. To maintain good practice, it’s recommended not to combine conventional and attribute-based routing within a single controller to avoid unpredicted behavior. As such, the controller should exclude itself from conventional routing by applying a [Route] attribute."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6934",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6960",
              "shortDescription": {
                "text": "Controllers should not have mixed responsibilities"
              },
              "fullDescription": {
                "text": "ASP.NET controllers should not have mixed responsibilities. Following the Single Responsibility Principle (SRP), they should be kept lean and focused on a single, separate concern. In short, they should have a single reason to change."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6960",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6961",
              "shortDescription": {
                "text": "API Controllers should derive from ControllerBase instead of Controller"
              },
              "fullDescription": {
                "text": "In ASP.NET Core, controllers usually inherit either from ControllerBase or Controller. If a controller does not use any View-specific functionality, it is recommended to inherit from ControllerBase."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6961",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6962",
              "shortDescription": {
                "text": "You should pool HTTP connections with HttpClientFactory"
              },
              "fullDescription": {
                "text": "In frequently used code paths, such as controller actions, you should avoid using the HttpClient directly and opt for one of the IHttpClientFactory-based mechanisms instead. This way, you avoid wasting resources and creating performance overhead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6962",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6964",
              "shortDescription": {
                "text": "Value type property used as input in a controller action should be nullable, required or annotated with the JsonRequiredAttribute to avoid under-posting."
              },
              "fullDescription": {
                "text": "\"Under-posting\" refers to a situation where a client sends less data than expected to the server during an HTTP request, for example when the client omits some properties from the request body that the server expects to receive."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6964",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6965",
              "shortDescription": {
                "text": "REST API actions should be annotated with an HTTP verb attribute"
              },
              "fullDescription": {
                "text": "When building a REST API, it’s recommended to annotate the controller actions with the available HTTP attributes to be precise about what your API supports."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6965",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6966",
              "shortDescription": {
                "text": "Awaitable method should be used"
              },
              "fullDescription": {
                "text": "In an async method, any blocking operations should be avoided."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6966",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.030",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6967",
              "shortDescription": {
                "text": "ModelState.IsValid should be called in controller actions"
              },
              "fullDescription": {
                "text": "In the context of ASP.NET Core MVC web applications, both model binding and model validation are processes that take place prior to the execution of a controller action. It is imperative for the application to examine the ModelState.IsValid and respond accordingly."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6967",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S6968",
              "shortDescription": {
                "text": "Actions that return a value should be annotated with ProducesResponseTypeAttribute containing the return type"
              },
              "fullDescription": {
                "text": "In an ASP.NET Core Web API, controller actions can optionally return a result value. If a controller action returns a value in the happy path, for example ControllerBase.Ok(Object), annotating the action with one of the [ProducesResponseType] overloads that describe the type is recommended."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-6968",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S818",
              "shortDescription": {
                "text": "Literal suffixes should be upper case"
              },
              "fullDescription": {
                "text": "Using upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-818",
              "properties": {
                "category": "Minor Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S881",
              "shortDescription": {
                "text": "Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression"
              },
              "fullDescription": {
                "text": "The use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:"
              },
              "defaultConfiguration": {
                "enabled": false
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-881",
              "properties": {
                "category": "Major Code Smell",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope"
                ]
              }
            },
            {
              "id": "S907",
              "shortDescription": {
                "text": "\"goto\" statement should not be used"
              },
              "fullDescription": {
                "text": "goto is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such as if, for, while, continue or break should be used instead."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-907",
              "properties": {
                "category": "Major Code Smell",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S927",
              "shortDescription": {
                "text": "Parameter names should match base declaration and other partial definitions"
              },
              "fullDescription": {
                "text": "Parameters are part of the method signature and its identity."
              },
              "helpUri": "https://rules.sonarsource.com/csharp/RSPEC-927",
              "properties": {
                "category": "Critical Code Smell",
                "executionTimeInSeconds": "0.004",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "C#",
                  "MainSourceScope",
                  "TestSourceScope",
                  "SonarWay"
                ]
              }
            },
            {
              "id": "S9999-cpd",
              "shortDescription": {
                "text": "Copy-paste token calculator"
              },
              "properties": {
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-log",
              "shortDescription": {
                "text": "Log generator"
              },
              "properties": {
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-metadata",
              "shortDescription": {
                "text": "File metadata generator"
              },
              "properties": {
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-metrics",
              "shortDescription": {
                "text": "Metrics calculator"
              },
              "properties": {
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-symbolRef",
              "shortDescription": {
                "text": "Symbol reference calculator"
              },
              "properties": {
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-token-type",
              "shortDescription": {
                "text": "Token type calculator"
              },
              "properties": {
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "S9999-warning",
              "shortDescription": {
                "text": "Analysis Warning generator"
              },
              "properties": {
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "MainSourceScope",
                  "TestSourceScope",
                  "Utility",
                  "NotConfigurable"
                ]
              }
            },
            {
              "id": "SYSLIB1045",
              "shortDescription": {
                "text": "Convert to 'GeneratedRegexAttribute'."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1045",
              "properties": {
                "category": "Performance",
                "executionTimeInSeconds": "0.017",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1054",
              "shortDescription": {
                "text": "Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time"
              },
              "fullDescription": {
                "text": "Use 'LibraryImportAttribute' instead of 'DllImportAttribute' to generate P/Invoke marshalling code at compile time"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1054",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.028",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1055",
              "shortDescription": {
                "text": "Invalid 'CustomMarshallerAttribute' usage"
              },
              "fullDescription": {
                "text": "A type with a 'System.Runtime.InteropServices.CustomMarshallerAttribute' must specify a non-'null' managed type"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1055",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1056",
              "shortDescription": {
                "text": "Specified marshaller type is invalid"
              },
              "fullDescription": {
                "text": "The unmanaged type for a custom marshaller must be a C# unmanaged type."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1056",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1057",
              "shortDescription": {
                "text": "Marshaller type does not have the required shape"
              },
              "fullDescription": {
                "text": "A stateless value marshaller that supports marshalling from managed to unmanaged must provide a one-parameter 'ConvertToUnmanaged' method that takes the managed value as the parameter and returns a value of the 'unmanaged' type."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1057",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1058",
              "shortDescription": {
                "text": "Invalid 'NativeMarshallingAttribute' usage"
              },
              "fullDescription": {
                "text": "An entry-point type for marshalling a given type must have a 'System.Runtime.InteropServices.CustomMarshallerAttribute' that specifies this type as the managed type."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1058",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1060",
              "shortDescription": {
                "text": "Specified marshaller type is invalid"
              },
              "fullDescription": {
                "text": "A marshaller type must either be a stateless static class or a stateful value type. A non-static class is not allowed."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1060",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1061",
              "shortDescription": {
                "text": "Marshaller type has incompatible method signatures"
              },
              "fullDescription": {
                "text": "The return type of 'GetPinnableReference' (after accounting for 'ref') must be blittable."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1061",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1090",
              "shortDescription": {
                "text": "'GeneratedComInterfaceType' does not support the 'ComInterfaceType' value supplied to 'InterfaceTypeAttribute' on the same type."
              },
              "fullDescription": {
                "text": "Using 'GeneratedComInterfaceAttribute' and 'InterfaceTypeAttribute' is not supported with 'ComInterfaceType' value '{0}'."
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1090",
              "properties": {
                "category": "ComInterfaceGenerator",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1096",
              "shortDescription": {
                "text": "Convert to 'GeneratedComInterface'"
              },
              "fullDescription": {
                "text": "Use 'GeneratedComInterfaceAttribute' instead of 'ComImportAttribute' to generate COM marshalling code at compile time"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1096",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1097",
              "shortDescription": {
                "text": "Add 'GeneratedComClassAttribute' to enable passing objects of this type to COM"
              },
              "fullDescription": {
                "text": "This type implements at least one type with the 'GeneratedComInterfaceAttribute' attribute. Add the 'GeneratedComClassAttribute' to enable passing this type to COM and exposing the COM interfaces for the types with the 'GeneratedComInterfaceAttribute' from objects of this type."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1097",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.006",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1098",
              "shortDescription": {
                "text": ".NET COM hosting with 'EnableComHosting' does not support interfaces with the 'GeneratedComInterfaceAttribute'"
              },
              "fullDescription": {
                "text": ".NET COM hosting with 'EnableComHosting' only supports built-in COM interop. It does not support source-generated COM interop with 'GeneratedComInterfaceAttribute'."
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1098",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "SYSLIB1099",
              "shortDescription": {
                "text": "COM Interop APIs on 'System.Runtime.InteropServices.Marshal' do not support source-generated COM"
              },
              "fullDescription": {
                "text": "COM Interop APIs on 'System.Runtime.InteropServices.Marshal' do not support source-generated COM and will fail at runtime"
              },
              "helpUri": "https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1099",
              "properties": {
                "category": "Interoperability",
                "executionTimeInSeconds": "0.027",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD001",
              "shortDescription": {
                "text": "Avoid legacy thread switching APIs"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD001.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.039",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD002",
              "shortDescription": {
                "text": "Avoid problematic synchronous waits"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD002.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD003",
              "shortDescription": {
                "text": "Avoid awaiting foreign Tasks"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD003.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.060",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD004",
              "shortDescription": {
                "text": "Await SwitchToMainThreadAsync"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD004.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.011",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD010",
              "shortDescription": {
                "text": "Invoke single-threaded types on Main thread"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD010.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.131",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "CompilationEnd"
                ]
              }
            },
            {
              "id": "VSTHRD011",
              "shortDescription": {
                "text": "Use AsyncLazy<T>"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD011.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.005",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD012",
              "shortDescription": {
                "text": "Provide JoinableTaskFactory where allowed"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD012.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.026",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD100",
              "shortDescription": {
                "text": "Avoid async void methods"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD100.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.007",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD101",
              "shortDescription": {
                "text": "Avoid unsupported async delegates"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD101.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD102",
              "shortDescription": {
                "text": "Implement internal logic asynchronously"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD102.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.009",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD103",
              "shortDescription": {
                "text": "Call async methods when in an async method"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD103.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.065",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD104",
              "shortDescription": {
                "text": "Offer async methods"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD104.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.003",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD105",
              "shortDescription": {
                "text": "Avoid method overloads that assume TaskScheduler.Current"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD105.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.016",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD106",
              "shortDescription": {
                "text": "Use InvokeAsync to raise async events"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD106.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.015",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD107",
              "shortDescription": {
                "text": "Await Task within using expression"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD107.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD108",
              "shortDescription": {
                "text": "Assert thread affinity unconditionally"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD108.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.032",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD109",
              "shortDescription": {
                "text": "Switch instead of assert in async methods"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD109.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.013",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD110",
              "shortDescription": {
                "text": "Observe result of async calls"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD110.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.496",
                "executionTimeInPercentage": "3"
              }
            },
            {
              "id": "VSTHRD111",
              "shortDescription": {
                "text": "Use ConfigureAwait(bool)"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD111.md",
              "properties": {
                "category": "Usage",
                "isEverSuppressed": "true",
                "suppressionKinds": [
                  "external"
                ],
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD112",
              "shortDescription": {
                "text": "Implement System.IAsyncDisposable"
              },
              "fullDescription": {
                "text": "The System.IAsyncDisposable interface is defined in the Microsoft.Bcl.AsyncInterfaces NuGet package."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD112.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD113",
              "shortDescription": {
                "text": "Check for System.IAsyncDisposable"
              },
              "fullDescription": {
                "text": "The System.IAsyncDisposable interface is defined in the Microsoft.Bcl.AsyncInterfaces NuGet package."
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD113.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.001",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD114",
              "shortDescription": {
                "text": "Avoid returning a null Task"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD114.md",
              "properties": {
                "category": "Usage",
                "executionTimeInSeconds": "0.002",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "VSTHRD200",
              "shortDescription": {
                "text": "Use \"Async\" suffix for async methods"
              },
              "helpUri": "https://github.com/Microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD200.md",
              "properties": {
                "category": "Style",
                "executionTimeInSeconds": "0.019",
                "executionTimeInPercentage": "<1"
              }
            },
            {
              "id": "CS1998",
              "shortDescription": {
                "text": "Async method lacks 'await' operators and will run synchronously"
              },
              "helpUri": "https://msdn.microsoft.com/query/roslyn.query?appId=roslyn&k=k(CS1998)",
              "properties": {
                "category": "Compiler",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Compiler",
                  "Telemetry"
                ]
              }
            },
            {
              "id": "CS1591",
              "shortDescription": {
                "text": "Missing XML comment for publicly visible type or member"
              },
              "fullDescription": {
                "text": "The /doc compiler option was specified, but one or more constructs did not have comments."
              },
              "helpUri": "https://msdn.microsoft.com/query/roslyn.query?appId=roslyn&k=k(CS1591)",
              "properties": {
                "category": "Compiler",
                "executionTimeInSeconds": "<0.001",
                "executionTimeInPercentage": "<1",
                "tags": [
                  "Compiler",
                  "Telemetry"
                ]
              }
            }
          ]
        }
      },
      "invocations": [
        {
          "executionSuccessful": true,
          "ruleConfigurationOverrides": [
            {
              "descriptor": {
                "id": "MA0026",
                "index": 432
              },
              "configuration": {
                "level": "warning"
              }
            },
            {
              "descriptor": {
                "id": "MA0026",
                "index": 432
              },
              "configuration": {
                "level": "note"
              }
            },
            {
              "descriptor": {
                "id": "S1135",
                "index": 886
              },
              "configuration": {
                "level": "warning"
              }
            },
            {
              "descriptor": {
                "id": "S1135",
                "index": 886
              },
              "configuration": {
                "level": "note"
              }
            }
          ]
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}